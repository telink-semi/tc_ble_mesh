/********************************************************************************************************
 * @file     mesh_crypto.c 
 *
 * @brief    for TLSR chips
 *
 * @author	 telink
 * @date     Sep. 30, 2010
 *
 * @par      Copyright (c) 2010, Telink Semiconductor (Shanghai) Co., Ltd.
 *           All rights reserved.
 *           
 *			 The information contained herein is confidential and proprietary property of Telink 
 * 		     Semiconductor (Shanghai) Co., Ltd. and is available under the terms 
 *			 of Commercial License Agreement between Telink Semiconductor (Shanghai) 
 *			 Co., Ltd. and the licensee in separate contract or the terms described here-in. 
 *           This heading MUST NOT be removed from this file.
 *
 * 			 Licensees are granted free, non-transferable use of the information in this 
 *			 file under Mutual Non-Disclosure Agreement. NO WARRENTY of ANY KIND is provided. 
 *           
 *******************************************************************************************************/
#include "le_crypto.h"
#include "mesh_crypto.h"
#include "../../proj_lib/sig_mesh/app_mesh.h"
#include "../../vendor/common/app_heartbeat.h"
//////////////////////////////////////////////////////////////////////////////////
//	cyprto function
//////////////////////////////////////////////////////////////////////////////////
void endianness_swap(u8 *nw, u8 swap_type);


void tn_aes_cmac ( unsigned char *key, unsigned char *input, int length,
                  unsigned char *mac );

//u8 security_enable = 1;	// 0: must provisioned before.

//typedef unsigned char u8;
//typedef unsigned short u16;

#ifndef AES_BLOCK_SIZE
#define AES_BLOCK_SIZE     16
#endif

typedef struct MESH_CCM_FLAGS_TAG {
    union {
        struct {
            u8 L : 3;
            u8 M : 3;
            u8 aData :1;
            u8 reserved :1;            
        } bf;
        u8 val;
    };
} mesh_ccm_flags_t;

#if 0
int str2hex (char * p)
{
	int i, a, b;//, v
	int n = strlen (p);
	for (i=0; i<n/2; i++)
	{
		a = *p++;
		b = *p++;
		printf ("0x%c%c,", a, b);
		if ((i%16) == 15)
		{
			printf ("\r\n");
		}
		else if ((i%8) == 7)
		{
			printf (" ");
		}
	}
	return i;
}
#endif

u8 mesh_ccmAuthTran(u8 micLen, u8 *key, u8 *iv, u8 *mStr, u16 mStrLen, u8 *aStr, u8 aStrLen, u8 *result)
{
	u8 newAstr[32] = {0};			// size should be greater or equal to (aStrLen + 2)
    u8 B[AES_BLOCK_SIZE];
    u8 tmpResult[AES_BLOCK_SIZE];
    u16 msgLen;
    u8 mStrIndex = 0;
    mesh_ccm_flags_t flags;
    int i,j;

    /* get B0 */
    flags.bf.L = 1;  /* L-1 (15-nonceLen-1)*/
    flags.bf.M = (micLen - 2)>>1;
    flags.bf.aData = (aStrLen > 0) ? 1 : 0;
    flags.bf.reserved = 0;
    
    B[0] = flags.val;
    /* copy nonce N */
    memcpy(B + 1, iv, 13);
    /* last byte is mStrlen */
    *(B+14) = mStrLen>>8;
    *(B+15) = mStrLen & 0xff;
	
	if (aStrLen)
	{
		u16 aStrLen_temp = aStrLen;
		newAstr[0] = aStrLen_temp>>8;
		newAstr[1] = aStrLen_temp & 0xff;
		memcpy(newAstr + 2, aStr, aStrLen);
		aStrLen += 2;

		  /* adjust msgLen according to aStrLen and mStrLen, should be 16x */
		if (aStrLen & 0x0f) {
			aStrLen &= ~0x0F;
			aStrLen += 0x10;
		}
	}
  
    msgLen = aStrLen;
 
    msgLen += mStrLen;
    if (mStrLen & 0x0f) {
        msgLen &= ~0x0F;
        msgLen += 0x10;
    }

	 /* X0 is zero */
    memset(tmpResult, 0, AES_BLOCK_SIZE);

    /* now the msgLen should be the length of AuthData, which is generated by AddAuthData (astring, padded by 0) || PlaintexeData (mString, padded by 0)*/
    for ( i=0; i<msgLen+16; i+=(1<<4) ) {
        for ( j=0; j<AES_BLOCK_SIZE; j++) {
            /* get Xi XOR Bi */
            tmpResult[j] ^= B[j];
        }
        /* use aes to get E(key, Xi XOR Bi) */
        tn_aes_128(key, tmpResult, tmpResult);

        /* update B */
        if ( aStrLen >= AES_BLOCK_SIZE ) {
            memcpy(B, newAstr + i, AES_BLOCK_SIZE);
            aStrLen -= AES_BLOCK_SIZE;
        } else if ( (aStrLen>0) && (aStrLen<AES_BLOCK_SIZE) ) {
            memcpy(B, newAstr + i, aStrLen);
            memset(B + aStrLen, 0, AES_BLOCK_SIZE - aStrLen);
            aStrLen = 0;
            /* reset the mstring index */
            mStrIndex = 0;
        } else if ( mStrLen >= AES_BLOCK_SIZE ) {
            memcpy(B, mStr + (mStrIndex*AES_BLOCK_SIZE), AES_BLOCK_SIZE);
            mStrIndex++;
            mStrLen -= AES_BLOCK_SIZE;
        } else {
            memcpy(B, mStr + (mStrIndex*AES_BLOCK_SIZE), mStrLen);
            memset(B + mStrLen, 0, AES_BLOCK_SIZE - mStrLen);
        }
    }
    memcpy(result, tmpResult, micLen);
    return 0;
}

u8 mesh_ccmBaseTran(u8 micLen, u8 *key, u8 *iv, u8 *mStr, u16 mStrLen, u8 *aStr, u8 aStrLen, u8 *mic, u8 opt)
{
    u8 A[AES_BLOCK_SIZE];
    u8 tmpResult[AES_BLOCK_SIZE];
    mesh_ccm_flags_t flags;
    u16 msgLen;
    u16 i;
    u8 j;
    u16 counter = 1;

    memset(&flags, 0, sizeof(mesh_ccm_flags_t));
    flags.bf.L = 1;
    A[0] = flags.val;

    /* set the iv */
    memcpy(A+1, iv, 13);

    A[14] = A[15] = 0;

    tn_aes_128(key, A, tmpResult);
    
    for ( i=0; i<micLen; i++ ) {
        mic[i] ^= tmpResult[i];
    }

    *(A+14) = counter>>8;
    *(A+15) = counter & 0xff;

    msgLen = mStrLen;
    if (msgLen & 0x0f) {
        msgLen &= ~0x0F;
        msgLen += 0x10;
    }

    for ( i=0; i<msgLen; i+=(1<<4) ) {
        /* use aes to the E(key, Ai) */
        tn_aes_128(key, A, tmpResult);
        //tmpResult = TODO();

        for ( j=0; (j<AES_BLOCK_SIZE) && (i+j < mStrLen); j++) {
            mStr[i+j] ^= tmpResult[j];
        }

        /* update Ai */
        counter++;
        *(A+14) = counter>>8;
        *(A+15) = counter & 0xff;
    }
	if (!opt)
	{
		memcpy (mStr + mStrLen, mic, micLen);
	}
    return 0;
}


int	mesh_sec_msg_enc_ll (unsigned char key[16], unsigned char nonce[13], unsigned char* dat, int n, u8 *aStr, u8 aStrLen, int mic_length)
{
	u8 mic[AES_BLOCK_SIZE];
	mesh_ccmAuthTran(mic_length, key, nonce, dat, n, aStr, aStrLen, mic);
	mesh_ccmBaseTran(mic_length, key, nonce, dat, n, aStr, aStrLen, mic, 0);
	memcpy (dat + n, mic, mic_length);
	return 0;
}

int	mesh_sec_msg_enc (unsigned char key[16], unsigned char nonce[13], unsigned char* dat, int n, int mic_length)
{
	return mesh_sec_msg_enc_ll(key, nonce, dat, n, 0, 0, mic_length);
}

int	mesh_sec_msg_dec_ll (unsigned char key[16], unsigned char nonce[13], unsigned char* dat, int n, u8 *aStr, u8 aStrLen, int mic_length)
{
	u8 tmpMic[AES_BLOCK_SIZE];
    u8 i;
	u8 *mic = dat + n - mic_length;
	mesh_ccmBaseTran(mic_length, key, nonce, dat, n - mic_length, aStr, aStrLen, mic, 1);
    mesh_ccmAuthTran(mic_length, key, nonce, dat, n - mic_length, aStr, aStrLen, tmpMic);
    for ( i=0; i<mic_length; i++ ) {
        if ( mic[i] != tmpMic[i] ) {
            return -1;
        }
    }
	
	return 0;
}

int	mesh_sec_msg_dec (unsigned char key[16], unsigned char nonce[13], unsigned char* dat, int n, int mic_length)
{
	return mesh_sec_msg_dec_ll(key, nonce, dat, n, 0, 0, mic_length);
}

int	mesh_sec_msg_obfuscation (unsigned char key[16], unsigned char iv[4], unsigned char* p_ctl)
{
	int i;
	u8 random[AES_BLOCK_SIZE] = {0, 0, 0, 0, 0};
	//u8 random[AES_BLOCK_SIZE] = {0x00,0x00,0x00,0x00,0x00,0x12,0x34,0x56, 0x78,0xb5,0xe7,0xbf,0xda,0xcb,0xaf,0x6c};
	memcpy (random + 5, iv , 4);
	memcpy (random + 9, p_ctl + 6, 7);
	tn_aes_128(key, random, random);
	for (i=0; i<6; i++)
	{
		p_ctl[i] ^= random[i];
	}
	return 0;
}

//-------------------------------------------------------------------------------------------------------
int mesh_sec_func_s1m (unsigned char *s1, char * m)
{
	unsigned char zero[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int n = (int )strlen (m);
	tn_aes_cmac (zero, (unsigned char *)m, n, s1);
	return 0;
}

int mesh_sec_func_s1 (unsigned char *s1, unsigned char * m, int n)
{
	unsigned char zero[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	tn_aes_cmac (zero, (unsigned char *)m, n, s1);
	return 0;
}

// T = AES-CMACSALT (N)		k1(N, SALT, P) = AES-CMACT (P)
int mesh_sec_func_k1 (unsigned char *k1, unsigned char * n, int nn, unsigned char *s, unsigned char * p, int np)
{
	unsigned char t[16];
	tn_aes_cmac (s, n, nn, t);
	tn_aes_cmac (t, p, np, k1);
	return 0;
}

int mesh_sec_func_k1_id (unsigned char *k1, unsigned char n[16])
{
	//salt = s1(¡°nkik¡±)
	//P = ¡°id128¡± || 0x01
	unsigned char s[16], t[16];
	mesh_sec_func_s1m (s, "nkik");
	k1[0] = 'i';
	k1[1] = 'd';
	k1[2] = '1';
	k1[3] = '2';
	k1[4] = '8';
	k1[5] = 0x01;
	tn_aes_cmac (s, n, 16, t);
	tn_aes_cmac (t, k1, 6, k1);
	return 0;
}

int mesh_sec_func_k1_beacon (unsigned char *k1, unsigned char n[16])
{
	//salt = s1(¡°nkik¡±)
	//P = ¡°id128¡± || 0x01
	unsigned char s[16], t[16];
	mesh_sec_func_s1m (s, "nkbk");
	k1[0] = 'i';
	k1[1] = 'd';
	k1[2] = '1';
	k1[3] = '2';
	k1[4] = '8';
	k1[5] = 0x01;
	tn_aes_cmac (s, n, 16, t);
	tn_aes_cmac (t, k1, 6, k1);
	return 0;
}

//SALT = s1(¡°smk2¡±)		T = AES-CMACSALT (N)
// T0 = empty string (zero length)
// T1 = AES-CMACT (T0 || P || 0x01)
// T2 = AES-CMACT (T1 || P || 0x02)
// T3 = AES-CMACT (T2 || P || 0x03)
// k2(N, P) = (T1 || T2 || T3) mod 2(263)
int mesh_sec_func_k2 (unsigned char *nid, unsigned char *ek, unsigned char *pk, unsigned char * n, unsigned char * p, int np)
{
	unsigned char t[16], s1[16];
	unsigned char tp[32];
	mesh_sec_func_s1m (s1, "smk2");
	tn_aes_cmac (s1, n, 16, t);

	memcpy (tp, p, np);
	tp[np] = 0x01;
	tn_aes_cmac (t, tp, np + 1, tp);
	*nid = tp[15] & 0x7f;
	
	memcpy (tp + 16, p, np);
	tp[np + 16] = 0x02;
	tn_aes_cmac (t, tp, np + 17, ek );

	memcpy (tp, ek, 16);
	memcpy (tp + 16, p, np);
	tp[np + 16] = 0x03;
	tn_aes_cmac (t, tp, np + 17, pk );
	return 0;
}

//SALT = s1(¡°smk3¡±)		T = AES-CMACSALT (N)
//k3(N) = AES-CMACT ( ¡°id64¡± || 0x01 ) mod 2(64)
int mesh_sec_func_k3 (unsigned char *k3, unsigned char n[16])
{
	unsigned char t[16];
	mesh_sec_func_s1m (t, "smk3");
	tn_aes_cmac (t, n, 16, t);
	k3[0] = 'i';
	k3[1] = 'd';
	k3[2] = '6';
	k3[3] = '4';
	k3[4] = 0x01;
	
	tn_aes_cmac (t, k3, 5, t);
	memcpy (k3, t + 8, 8);
	return 0;
}

//SALT = s1(¡°smk4¡±)		T = AES-CMACSALT (N)
//k3(N) = AES-CMACT ( ¡°id64¡± || 0x01 ) mod 2(64)
int mesh_sec_func_k4 (unsigned char *k4, unsigned char n[16])
{
	unsigned char t[16];
	mesh_sec_func_s1m (t, "smk4");
	tn_aes_cmac (t, n, 16, t);
	k4[0] = 'i';
	k4[1] = 'd';
	k4[2] = '6';
	k4[3] = 0x01;
	
	tn_aes_cmac (t, k4, 4, t);
	k4[0] = t[15] & 0x3f;
	return 0;
}

//Authentication Value = AES-CMACBeaconKey (Flags || Network ID || IV Index) [0¨C7]
int mesh_sec_beacon_auth (unsigned char *key, unsigned char *m, int dec)
{
	unsigned char t[16];

	tn_aes_cmac (key, m, 13, t);
	
	if (dec)
	{
		if (memcmp (m + 13, t, 8))
		{
			return 1;
		}
	}
	else
	{
		memcpy (m + 13, t, 8);
	}
	
	return 0;
}

int mesh_sec_beacon_dec (unsigned char *m)
{
	int err = -1;
	
	u8 bc_backup[21];	// sizeof(mesh_beacon_sec_nw_t)
	memcpy(bc_backup, m, sizeof(bc_backup));
	int dirty_flag = 0;
	
    foreach(i,NET_KEY_MAX){
		u32 cnt = is_key_refresh_use_old_and_new_key(i) ? 2 : 1;
		u32 only_new_key_flag = (KEY_REFRESH_PHASE2 == key_refresh_phase_get(i));
    	for(unsigned int k = only_new_key_flag; k < (cnt); ++k){
	        mesh_net_key_t *key = &mesh_key.net_key[i][k];
	        if(KEY_UNVALID != key->valid){
	        	if(dirty_flag){
					memcpy(m, bc_backup, sizeof(bc_backup));
	        	}
				dirty_flag = 1;
    			err = mesh_sec_beacon_auth(key->bk, m, 1);
    			if(!err){
    				mesh_key.netkey_sel_dec = i;
    				mesh_key.new_netkey_dec = (k!=0);
    				return 0;
    			}
    		}
    	}
    }

    return -1;
}

//ConfirmationKey = k1(ECDHSecret, ConfirmationSalt, ¡°prck¡±)
int mesh_sec_prov_confirmation_key (unsigned char *key, unsigned char *input, int n, unsigned char ecdh[32])
{
	unsigned char s[16];
	mesh_sec_func_s1 (s, input, n);
	mesh_sec_func_k1 (key, ecdh, 32, s, (unsigned char*)"prck", 4);	
	return 0;
}

//ConfirmationKey = k1(ECDHSecret, ConfirmationSalt, ¡°prck¡±)
int mesh_sec_prov_confirmation (unsigned char *cfm, unsigned char *input, int n, unsigned char ecdh[32],
									unsigned char random[16], unsigned char auth[16])
{
	unsigned char s[32];
	mesh_sec_func_s1 (s, input, n);
	mesh_sec_func_k1 (cfm, ecdh, 32, s, (unsigned char*)"prck", 4);	
	memcpy (s, random, 16);
	memcpy (s+16, auth, 16);
	tn_aes_cmac (cfm, s, 32, cfm);
	return 0;
}
void mesh_sec_prov_salt(unsigned char prov_salt[16],unsigned char *input,unsigned char randomProv[16], unsigned char randomDev[16])
{
	unsigned char s[48];
	mesh_sec_func_s1 (s, input, 145);
	memcpy (s + 16, randomProv, 16);
	memcpy (s + 32, randomDev, 16);
	mesh_sec_func_s1 (s, s, 48);
	memcpy(prov_salt,s,16);

}
//ConfirmationKey = k1(ECDHSecret, ConfirmationSalt, ¡°prck¡±)
int mesh_sec_prov_session_key (unsigned char sk[16], unsigned char *sn, unsigned char *input, int n, unsigned char ecdh[32],
									unsigned char randomProv[16], unsigned char randomDev[16])
{
	unsigned char s[48];
	mesh_sec_func_s1 (s, input, n);
	memcpy (s + 16, randomProv, 16);
	memcpy (s + 32, randomDev, 16);
	mesh_sec_func_s1 (s, s, 48);

	mesh_sec_func_k1 (sk, ecdh, 32, s, (unsigned char*)"prsk", 4);
	mesh_sec_func_k1 (sn, ecdh, 32, s, (unsigned char*)"prsn", 4);

	return 0;
}
// dev key = k1(ECDHSecret, provisioningSalt, ¡°prdk¡±)
int mesh_sec_dev_key (unsigned char dev_key[16], unsigned char *salt, unsigned char ecdh[32])
{
	mesh_sec_func_k1 (dev_key, ecdh, 32, salt, (unsigned char*)"prdk", 4);
	return 0;
}

void mesh_nonce_set_network(u8 *nonce, u8 *iv, const u8 *ctl_ttl_big)
{
    //mesh_cmd_nw_t *p_nw = (mesh_cmd_nw_t *)nw;
	nonce[0] = NONCE_TYPE_NETWORK;
	memcpy (nonce + 1, ctl_ttl_big, 6);    // from ctl_ttl
	nonce[7] = 0;    // pad
	nonce[8] = 0;    // pad
	memcpy (nonce + 9 , iv, 4);
}

void mesh_nonce_set_application(u8 *nonce, u8 *iv, const u8 *nw_little, u8 akf)
{
    mesh_cmd_nw_t nw_t;
    mesh_cmd_nw_t *p_nw_i = (mesh_cmd_nw_t *)nw_little;
    memcpy(nw_t.sno, p_nw_i->sno, 7);
    endianness_swap((u8 *)&nw_t, SWAP_TYPE_NW);

    mesh_cmd_lt_seg_t *p_lt_seg = (mesh_cmd_lt_seg_t *)(p_nw_i->data);
    u32 szmic = 0;
    if(p_lt_seg->seg){
    	szmic = p_lt_seg->szmic;
    }
    
    nonce[0] = akf ? NONCE_TYPE_APPLICATION : NONCE_TYPE_DEVICE;
	nonce[1] = szmic << 7;    // pad
	memcpy (nonce + 2, nw_t.sno, 7);
	memcpy (nonce + 9 , iv, 4);
}
void mesh_nonce_set_proxy(u8 *nonce,u8 *iv,const u8 *nw_big)
{
    mesh_cmd_nw_t *p_nw = (mesh_cmd_nw_t *)nw_big;
	nonce[0]=NONCE_TYPE_PROXY;
	nonce[1]=0;
	memcpy(nonce+2,p_nw->sno,5);
	nonce[7] = 0;    // pad
	nonce[8] = 0;    // pad
	memcpy(nonce+9,iv,4);
}

inline void swap_u8(u8 *a, u8 *b){
    u8 temp = *a;
    *a = *b;
    *b = temp;
}

void endianness_swap_u32(u8 *data){
    swap_u8(data, data+3);
    swap_u8(data+1, data+2);
}

void endianness_swap_u16(u8 *data){
    swap_u8(data, data+1);
}

void endianness_swap_u24(u8 *data){
    swap_u8(data, data+2);
}
void endianness_swap_u48(u8 *data){
    swap_u8(data, data+5);
	swap_u8(data+1, data+4);
	swap_u8(data+2, data+3);
}

void endianness_swap_u64(u8 *data){
    u8 tmp[8];
    swap64(tmp, data);
    memcpy(data, tmp, 8);
}

void endianness_swap(u8 *nw, u8 swap_type){
    //if(!security_enable){return;}

    mesh_cmd_nw_t *p_nw = (mesh_cmd_nw_t *)nw;
    if(SWAP_TYPE_NW == swap_type){
        endianness_swap_u24(p_nw->sno);
        endianness_swap_u16((u8 *)&p_nw->src);
        endianness_swap_u16((u8 *)&p_nw->dst);
    }else if((SWAP_TYPE_LT_SEG == swap_type)||(SWAP_TYPE_LT_CTL_SEG == swap_type)){
        endianness_swap_u24(p_nw->data + 1); // mesh_cmd_lt_seg_t, mesh_cmd_lt_ctl_seg_t
    }else if(SWAP_TYPE_LT_CTL_SEG_ACK == swap_type){
        endianness_swap_u16(p_nw->data + 1);
        mesh_cmd_lt_ctl_seg_ack_t *p_lt_ack = (mesh_cmd_lt_ctl_seg_ack_t *)p_nw->data;
        endianness_swap_u32(p_lt_ack->seg_map);
    }else if(SWAP_TYPE_LT_CTL_UNSEG == swap_type){
        mesh_cmd_lt_ctl_unseg_t *p_lt = (mesh_cmd_lt_ctl_unseg_t *)p_nw->data;
        u8 op = p_lt->opcode;
        if(CMD_CTL_REQUEST == op){
            mesh_ctl_fri_req_t *fri_req_tmp = (mesh_ctl_fri_req_t *)p_lt->data;
            endianness_swap_u24((u8 *)(&fri_req_tmp->Criteria)+2);	// PollTimeout
            endianness_swap_u16((u8 *)(&fri_req_tmp->PreAdr));
            endianness_swap_u16((u8 *)(&fri_req_tmp->LPNCounter));
        }else if(CMD_CTL_OFFER == op){
            mesh_ctl_fri_offer_t *fri_offer_tmp = (mesh_ctl_fri_offer_t *)p_lt->data;
            endianness_swap_u16((u8 *)(&fri_offer_tmp->FriCounter));
        }else if(CMD_CTL_POLL == op){
            // none
        }else if(CMD_CTL_UPDATE == op){
            // none, because iv_idx_st.tx store in big endianness
        }else if(CMD_CTL_CLEAR == op || CMD_CTL_CLR_CONF == op){
        	mesh_ctl_fri_clear_t *p_fri_clear = (mesh_ctl_fri_clear_t *)p_lt->data;
            endianness_swap_u16((u8 *)&p_fri_clear->LPNAdr);
            endianness_swap_u16((u8 *)&p_fri_clear->LPNCounter);
        }else if(CMD_CTL_SUBS_LIST_ADD == op || CMD_CTL_SUBS_LIST_REMOVE == op){
            mesh_cmd_bear_unseg_t *p_br = CONTAINER_OF((mesh_cmd_nw_t *)nw,mesh_cmd_bear_unseg_t,nw);
            u32 subsc_cnt = mesh_subsc_adr_cnt_get(p_br);
            foreach(i,subsc_cnt){
                endianness_swap_u16(p_lt->data + (1 + i*2));
            }
        }
		else if(CMD_CTL_HEARTBEAT == op){
			mesh_hb_msg_t *hb_msg = (mesh_hb_msg_t *)p_lt->data;
			endianness_swap_u16((u8 *)&hb_msg->fea);
		}
    }
}

void mesh_swap_nw_lt(u8 *nw, u8 swap_type_lt)
{
    endianness_swap(nw, swap_type_lt);     // must first
    endianness_swap(nw, SWAP_TYPE_NW);    
}

void endianness_swap_fri_sec_par(u8 *fri_sec_par)
{
    mesh_fri_sec_par_t *p_fri_sec_par = (mesh_fri_sec_par_t *)fri_sec_par;
    endianness_swap_u16((u8 *)&p_fri_sec_par->LPNAdr);
    endianness_swap_u16((u8 *)&p_fri_sec_par->FriAdr);
    endianness_swap_u16((u8 *)&p_fri_sec_par->LPNCounter);
    endianness_swap_u16((u8 *)&p_fri_sec_par->FriCounter);
}

int  mesh_sec_msg_enc_apl(u8 *mat, u8 *bear, int mic_length)
{
    mesh_cmd_bear_unseg_t *p_bear = (mesh_cmd_bear_unseg_t *)bear;
    mesh_cmd_nw_t *nw_little = &p_bear->nw;
    mesh_cmd_lt_unseg_t *p_lt_unseg = &p_bear->lt;
    u8 akf = p_lt_unseg->akf;

	material_tx_cmd_t *p = (material_tx_cmd_t *)mat;
    if(!SECURITY_ENABLE){
		//LOG_MSG_INFO(TL_LOG_MESH,0, 0,"not security enable return ");
        memset(p->p_ac + p->len_ac, 0, mic_length);   // clear last comannd
        return 0;
    }
    
    u8 r_an[13];
    mesh_nonce_set_application(r_an, iv_idx_st.tx, (u8 *)nw_little, akf);
	mesh_app_key_t *p_key_str = NULL;
    p_key_str = mesh_tx_access_key_get(mat, akf);
    if(!p_key_str){
        if(akf){
		    LOG_MSG_ERR(TL_LOG_COMMON,0, 0,"not found app key",0);
		}else{
		    LOG_MSG_ERR(TL_LOG_COMMON,0, 0,"not found device key",0);
		}
    	return -1;
    }

    if(p_lt_unseg->akf){
        p_lt_unseg->aid = p_key_str->aid;
    }else{
        p_lt_unseg->aid = 0;
    }

	u8 *uuid = 0;
	u32 uuid_len = 0;
	if(akf && p->uuid && is_virtual_adr(p->adr_dst)){
		uuid = p->uuid;
		uuid_len = 16;
	}
    
    mesh_sec_msg_enc_ll (p_key_str->key, r_an, p->p_ac, p->len_ac, uuid, uuid_len, mic_length);

    return 0;
}

int  mesh_sec_msg_dec_apl(u8 *ac, u16 len_ut, const u8 *nw_little)
{
    if(!SECURITY_ENABLE){
    	mesh_key.appkey_sel_dec = 0;
    	return 0;
    }
    
    if(mesh_key.netkey_sel_dec >= NET_KEY_MAX){
        LOG_MSG_ERR(TL_LOG_MESH,0, 0 ,"invalid Network key index ",0);
        return -1;
    }
    
	mesh_cmd_bear_seg_t *p_br = CONTAINER_OF((mesh_cmd_nw_t *)nw_little,mesh_cmd_bear_seg_t,nw);
    u8 r_an[13];
    mesh_nonce_set_application(r_an, iv_idx_st.rx, nw_little, p_br->lt.akf);
	mesh_key.appkey_sel_dec = -1;		// init
	mesh_key.devkey_self_dec = -1;		// init

	int mic_length = p_br->lt.seg ? (p_br->lt.szmic ? SZMIC_TRNS_SEG64 : SZMIC_TRNS_SEG32) : SZMIC_TRNS_UNSEG;
    u8 ac_backup[ACCESS_WITH_MIC_LEN_MAX];
    memcpy(ac_backup, ac, len_ut);
    int dirty_flag = 0;

	if(p_br->lt.akf){	
		static u16 T_1_ak;T_1_ak++;
		u8 nk_array_idx = mesh_key.netkey_sel_dec;
		u32 cnt = is_key_refresh_use_old_and_new_key(nk_array_idx) ? 2 : 1;
		foreach(k,cnt){
			foreach(i,APP_KEY_MAX){
				mesh_app_key_t *key = &mesh_key.net_key[nk_array_idx][k].app_key[i];
				if(KEY_UNVALID != key->valid){
					if(p_br->lt.aid == key->aid){
						if(dirty_flag){
							memcpy(ac, ac_backup, len_ut); // restore access data
						}
						dirty_flag = 1;
						
						if(is_virtual_adr(p_br->nw.dst)){
							if(!mesh_sec_msg_dec_virtual(key->key, r_an, ac, len_ut, mic_length, p_br->nw.dst, ac_backup)){
								mesh_key.appkey_sel_dec = i;
								return 0;
							}
						}else{
							if(!mesh_sec_msg_dec(key->key, r_an, ac, len_ut, mic_length)){
								mesh_key.appkey_sel_dec = i;
								#if 0
								static u32 ts_A_18_dec_ok;
								static u8 ts_A_18_dec_buf[31][16];
								if(ts_A_18_dec_ok < 31){
									memcpy(ts_A_18_dec_buf[ts_A_18_dec_ok], ac, 16);
								}
								ts_A_18_dec_ok++;
								#endif
								return 0; // decryption success
							}
						}
					}
				}
			}
		}
        LOG_MSG_ERR(TL_LOG_MESH,0, 0 ,"app key decryption error ",0);
		static u16 T_11_ak_ak_err;T_11_ak_ak_err++;
	}else{
        int err = -1;
		u8 *dev_key = mesh_cfg_cmd_dev_key_get(p_br->nw.src);
		static u16 T_2_dk;T_2_dk++;
		if(dev_key){
            err = mesh_sec_msg_dec(dev_key, r_an, ac, len_ut, mic_length);
            if(err){
                dirty_flag = 1;
                LOG_MSG_ERR(TL_LOG_MESH,0, 0 ,"device key decryption error ",0);
                static u16 T_2_dk_err;T_2_dk_err++;
            }else{
                #if 0
                static u32 ts_A_19_dec_ok;
                static u8 ts_A_19_dec_buf[31][16];
                if(ts_A_19_dec_ok < 31){
                    memcpy(ts_A_19_dec_buf[ts_A_19_dec_ok], ac, 16);
                }
                ts_A_19_dec_ok++;
                #endif
            }
		}

        #if (__PROJECT_MESH_PRO__ || __PROJECT_MESH_GW_NODE__)
		if(err && (ele_adr_primary != p_br->nw.src)){
            if(dirty_flag){
                memcpy(ac, ac_backup, len_ut); // restore access data
            }
            
            dev_key = mesh_cfg_cmd_dev_key_get(ele_adr_primary);
        	err = mesh_sec_msg_dec(dev_key, r_an, ac, len_ut, mic_length);
		}
		#endif

		if(!err){
            mesh_key.devkey_self_dec = (dev_key == mesh_key.dev_key);
		    if((0 == mesh_key.devkey_self_dec) && !memcmp(dev_key,mesh_key.dev_key,16)){
		        mesh_key.devkey_self_dec = DEC_BOTH_TWO_DEV_KEY;
		    }
        }else{
			LOG_MSG_ERR(TL_LOG_MESH,0, 0 ,"decryption: device key not found",0);
        }
		
		return err;
	}
	
	return -1;
}

int  mesh_sec_msg_enc_nw_rf_buf(u8 *nw, u8 len_lt, int use_friend_key,u8 cfg_filter, u8 nk_array_idx)
{
    mesh_cmd_nw_t *p_nw = (mesh_cmd_nw_t *)nw;
    
	int new_key_flag = is_key_refresh_use_new_key(nk_array_idx);
    u8 *p_ek, *p_pk;
    mesh_net_key_t *p_net_key = &(mesh_key.net_key[nk_array_idx][new_key_flag]);
    if(!p_net_key->valid){
    	return -1;
    }
    
    if(use_friend_key){
    	u8 lpn_idx = use_friend_key - 1;
    	#if FEATURE_LOWPOWER_EN
    	lpn_idx = lpn_idx;
        friend_key_t * p_fri_key = &mesh_fri_key_lpn[nk_array_idx][new_key_flag];
        #else
        friend_key_t * p_fri_key = &mesh_fri_key_fn[lpn_idx][new_key_flag];
        #endif
        p_ek = p_fri_key->ek_f;
        p_pk = p_fri_key->pk_f;
        p_nw->nid = p_fri_key->nid_f;
    }else{
        p_ek = p_net_key->ek_m;
        p_pk = p_net_key->pk_m;
        p_nw->nid = p_net_key->nid_m;
    }
    p_nw->ivi = iv_idx_st.tx[3];

    if(SECURITY_ENABLE){
        u8 r_nn[13];
        u8 *p_ctl_ttl = ((u8 *)p_nw) + 1;
		if(cfg_filter){
			mesh_nonce_set_proxy(r_nn, iv_idx_st.tx, (u8 *)p_nw);
		}else{
			mesh_nonce_set_network(r_nn, iv_idx_st.tx, p_ctl_ttl);
		} 
        mesh_sec_msg_enc(p_ek, r_nn, (u8 *)&p_nw->dst, len_lt+2, p_nw->ctl ? SZMIC_NW64 : SZMIC_NW32);
        mesh_sec_msg_obfuscation (p_pk, iv_idx_st.tx, p_ctl_ttl);
    }else{
        memset(p_nw->data + len_lt, 0, p_nw->ctl ? SZMIC_NW64 : SZMIC_NW32);  // init network MIC
        u8 len_nw_mic = len_lt+(p_nw->ctl ? SZMIC_NW64 : SZMIC_NW32);
        if(use_friend_key){
            p_nw->data[len_nw_mic-4] = FRIEND_KEY_NO_SECU_FLAG;
        }
        memcpy(p_nw->data+(len_nw_mic-3), iv_idx_st.tx+1, 3);   // only use 3 BYTES of ivi to comapre
    }

    return 0;

}

int  mesh_sec_msg_enc_nw(u8 *nw, u8 len_lt, u8 swap_type_lt, int use_friend_key, u8 len_nw, u8 adv_type,u8 cfg_filter, u8 nk_array_idx)
{
    mesh_cmd_bear_unseg_t *p_br = CONTAINER_OF((mesh_cmd_nw_t *)nw,mesh_cmd_bear_unseg_t,nw);
    p_br->len = len_nw + 1;
    p_br->type = adv_type;
    
    mesh_swap_nw_lt(nw, swap_type_lt);
    return mesh_sec_msg_enc_nw_rf_buf(nw, len_lt, use_friend_key,cfg_filter, nk_array_idx);
}

int message_nw_layer_adv_check(const u8 *nw_big, u8 len_dec_nw)
{
	mesh_cmd_nw_t nw_temp = {0};
	memcpy(&nw_temp, nw_big, min2(sizeof(nw_temp), len_dec_nw));
    endianness_swap((u8 *)&nw_temp, SWAP_TYPE_NW);

#if (0 == MESH_MONITOR_EN)
    if(mesh_adr_check_src_own_rx(nw_temp.src)){
        LAYER_PARA_DEBUG(A_debug_network_src_err);
        return -ERR_NO_NW_DEC_ADR_INVALID;
    }
#endif

    // cache compare
    if(is_exist_in_cache((u8 *)&nw_temp, 0, 0)){  // don't save cache, just compare, because it may be a invalid message
        LAYER_PARA_DEBUG(A_debug_network_exist_in_cache);
        #if 0
        if(!p_nw->ctl){
            mesh_cmd_nw_t nw_temp;
            memcpy(&nw_temp, p_nw, sizeof(mesh_cmd_nw_t));
            endianness_swap((u8 *)&nw_temp, SWAP_TYPE_LT_SEG);
            mesh_cmd_lt_seg_t *p_lt_seg_temp = (mesh_cmd_lt_seg_t *)(&nw_temp.data);
            if(p_lt_seg_temp->seg && (p_lt_seg_temp->seqzero == mesh_rx_seg_par.seqzero)){
            }else{
                return -ERR_NO_NW_DEC_CACHE_OLD;
            }
        }else
        #endif
        {
            return -ERR_NO_NW_DEC_CACHE_OLD;
        }
    }

    return 0;   // 0 means valid
}

int  mesh_sec_msg_dec_nw2(u8 *nw, u8 len_dec_nw, u8 *ek, u8 *pk,u8 cfg_filter, int src_type)
{  
	u8 nw_org[sizeof(mesh_cmd_nw_t)];
	if(len_dec_nw>sizeof(mesh_cmd_nw_t)){
		LOG_MSG_INFO(TL_LOG_WIN32,nw, len_dec_nw,"mesh_sec_msg_dec_nw2 %d \r\n",len_dec_nw);
		return -ERR_NO_NW_DEC_ERR;
	}
	memcpy(nw_org, nw, len_dec_nw);
	
    int err;
    u8 *p_ctl_ttl = nw + 1;
	mesh_sec_msg_obfuscation (pk, iv_idx_st.rx, p_ctl_ttl);
	
	mesh_cmd_nw_t *p_nw = (mesh_cmd_nw_t *)nw;
	#if (0 == FEATURE_LOWPOWER_EN)
    if(ADV_FROM_MESH == src_type){
        err = message_nw_layer_adv_check(nw, len_dec_nw);
        if(err){
            memcpy(nw, nw_org, len_dec_nw);//restore nw data
            return err;
        }
    }
    #endif
	
    u8 r_nn[13];
	if(cfg_filter){
		mesh_nonce_set_proxy(r_nn, iv_idx_st.rx, nw);
	}else{
    	mesh_nonce_set_network(r_nn, iv_idx_st.rx, p_ctl_ttl);
	}
	err = mesh_sec_msg_dec (ek, r_nn, (u8 *)&p_nw->dst, len_dec_nw, p_nw->ctl ? SZMIC_NW64 : SZMIC_NW32);
    if(cfg_filter){
        #if WIN32
        proxy_config_pdu_sr *p_proxy_str;
    	p_proxy_str = (proxy_config_pdu_sr *)(p_nw->data);
	    LOG_MSG_INFO(TL_LOG_NODE_BASIC,p_proxy_str->para+1,4 ,"the filter rsp is %d",p_proxy_str->para[0]);
	    #endif
    }    
	if(err){
		memcpy(nw, nw_org, len_dec_nw);//restore nw data
	}else{
        endianness_swap(nw, SWAP_TYPE_NW);
	}
    return err;
}

int  mesh_sec_msg_dec_nw(u8 *nw, int len_dec_nw_int, u8 nid, u8 *friend_key_flag,u8 cfg_filter, int src_type)
{
    if(len_dec_nw_int < 0){
        return -ERR_NO_NW_DEC_ERR;
    }
    u8 len_dec_nw = (u8)len_dec_nw_int;

    mesh_cmd_nw_t *p_nw = (mesh_cmd_nw_t *)nw;
    mesh_set_iv_idx_rx(p_nw->ivi);
    
    *friend_key_flag = 0;
    if(!SECURITY_ENABLE){
		mesh_key.netkey_sel_dec = 0;
		mesh_key.new_netkey_dec = 0;
        endianness_swap(nw, SWAP_TYPE_NW);
        u8 len_nw_mic = OFFSETOF(mesh_cmd_nw_t,dst)+len_dec_nw;
        if(memcmp(nw+len_nw_mic-3, iv_idx_st.rx+1, 3)){
            return -ERR_NO_NW_DEC_ERR;
        }
        
        *friend_key_flag = (FRIEND_KEY_NO_SECU_FLAG == nw[len_nw_mic-4]);
        if(is_fn_support_and_en){
            if(is_must_use_friend_key_msg(p_nw)){
                if(0 == *friend_key_flag){
                    static u32 T_key_error1;T_key_error1++;
                    return -ERR_NO_NW_DEC_ERR;
                }
            }
        }else if(is_lpn_support_and_en){
            if(is_in_mesh_friend_st_lpn()){
                if(0 == *friend_key_flag){
                    static u32 T_key_error2;T_key_error2++;
                    return -ERR_NO_NW_DEC_ERR;
                }
            }
        }
        
        return 0;
    }
    
    //int err;    
    foreach(i,NET_KEY_MAX){
		u32 cnt = is_key_refresh_use_old_and_new_key(i) ? 2 : 1;
    	foreach(k,cnt){
	        mesh_net_key_t *key = &mesh_key.net_key[i][k];
	        if(KEY_UNVALID != key->valid){       	
	            if(nid == key->nid_m){
	                int err2 = mesh_sec_msg_dec_nw2(nw, len_dec_nw, key->ek_m, key->pk_m, cfg_filter, src_type);
                    if(0 == err2){
                        if(is_fn_support_and_en){
                            if(p_nw->ctl && is_unicast_friend_msg_from_lpn(p_nw)){
                                mesh_cmd_bear_unseg_t *p_br = CONTAINER_OF(p_nw,mesh_cmd_bear_unseg_t,nw);
                                if(CMD_CTL_CLEAR != p_br->lt_ctl_unseg.opcode){
    								static u16 T_key_error3;T_key_error3++;
                                    return -ERR_NO_NW_DEC_ERR;  // should use friend key
                                }
                            }
                        }else if(is_lpn_support_and_en){
                            int valid = 0;
                            if(ADV_FROM_MESH==src_type){
                                if(is_in_mesh_friend_st_lpn()){
                                	if(mesh_lpn_par.FriAdr == p_nw->src){
                                		if(!is_must_use_friend_key_msg(p_nw)){
                                			*friend_key_flag = 1;
                                			valid = 1;
                                		}
                                	}
                            	}else{
                            	    if(mesh_lpn_rx_master_key){
                            	        valid = 1;
                            	    }else{
                                        // only receive offer command before establish friend ship when provision ok and reboot.
                                	    if(p_nw->ctl){
                                	        mesh_cmd_bear_unseg_t *p_bear = CONTAINER_OF(p_nw,mesh_cmd_bear_unseg_t,nw);
                                            mesh_cmd_lt_ctl_unseg_t *p_lt_ctl_unseg = (mesh_cmd_lt_ctl_unseg_t *)&p_bear->lt;
                                            if(CMD_CTL_OFFER == p_lt_ctl_unseg->opcode){
                                	            valid = 1;
                                	        }
                                	    }
                            	    }
                            	}
                        	}else{	// GATT always valid
                        	    valid = 1;
                        	}
                        	
                        	if(!valid){
                        	    return -ERR_NO_NW_DEC_ERR;
                        	}
                        }
                        mesh_key.netkey_sel_dec = i;
                        mesh_key.new_netkey_dec = (k!=0);
                        return 0; // decryption success
                    }else if(-ERR_NO_NW_DEC_ERR != err2){
                        return err2;
                    }else{
                        static u16 T_confilc_nid_cnt;T_confilc_nid_cnt++;
                    }
	            }

				int fn_key_dec_ok = 0;
	            if(is_lpn_support_and_en){
	                #if FEATURE_LOWPOWER_EN
                    friend_key_t * p_fri_key = &mesh_fri_key_lpn[i][k];
	            	if((nid == p_fri_key->nid_f) && is_in_mesh_friend_st_lpn()){
	            	    int err2 = mesh_sec_msg_dec_nw2(nw, len_dec_nw, p_fri_key->ek_f, p_fri_key->pk_f,cfg_filter,src_type);
		                if(0 == err2){
	                        fn_key_dec_ok = 1;
		                }else if(-ERR_NO_NW_DEC_ERR != err2){
		                    return err2;
		                }
	                }
	                #endif
	            }else if(is_fn_support_and_en){
	            	foreach(m,g_max_lpn_num){
                        friend_key_t * p_fri_key = &mesh_fri_key_fn[m][k];
		            	if(fn_other_par[m].LPNAdr && (nid == p_fri_key->nid_f)){
			                int err2 = mesh_sec_msg_dec_nw2(nw, len_dec_nw, p_fri_key->ek_f, p_fri_key->pk_f,cfg_filter,src_type);
			                if(0 == err2){
								fn_key_dec_ok = 1;
								break;
			                }else if(-ERR_NO_NW_DEC_ERR != err2){
			                    return err2;
			                }
		                }
	                }
	            }

	            if(fn_key_dec_ok){
					*friend_key_flag = 1;
					mesh_key.netkey_sel_dec = i;
					mesh_key.new_netkey_dec = (k!=0);
					return 0; // decryption success
	            }
	        }
        }
    }
    
    return -ERR_NO_NW_DEC_ERR;
}

u8 mesh_sec_get_aid(u8 *key)
{
    u8 r[16];
    mesh_sec_func_k4(r, key);
    return r[0];
}

void mesh_sec_get_nid_ek_pk_master(u8 *nid, u8 *ek, u8 *pk, u8 *nk)
{
    u8 k2_p[1] = {0};
    mesh_sec_func_k2 (nid, ek, pk, nk, k2_p, 1);
}

void mesh_sec_get_nid_ek_pk_friend(u8 lpn_idx, u8 *nid, u8 *ek, u8 *pk, u8 *nk)
{
    //k2(NetKey, 0x01 || LPNAddress || FriendAddress || LPNCounter || FriendCounter) // big endianness
    mesh_fri_sec_par_t fri_sec_par;
    fri_sec_par.flag = 1;
    #if FEATURE_LOWPOWER_EN
    fri_sec_par.LPNAdr = mesh_lpn_par.LPNAdr;
    fri_sec_par.FriAdr = mesh_lpn_par.FriAdr;
    fri_sec_par.LPNCounter = mesh_lpn_par.req.LPNCounter;
    fri_sec_par.FriCounter = mesh_lpn_par.offer.FriCounter;
    #else
    fri_sec_par.LPNAdr = fn_other_par[lpn_idx].LPNAdr;
    fri_sec_par.FriAdr = fn_other_par[lpn_idx].FriAdr;
    fri_sec_par.LPNCounter = fn_req[lpn_idx].LPNCounter;
    fri_sec_par.FriCounter = fn_offer[lpn_idx].FriCounter;
    #endif
    endianness_swap_fri_sec_par((u8 *)&fri_sec_par);
    mesh_sec_func_k2 (nid, ek, pk, nk, &fri_sec_par.flag, 9);
}

void mesh_sec_get_network_id(u8 *nw_id, u8 *nk)
{
    mesh_sec_func_k3(nw_id, nk);
    //endianness_swap_u64(nw_id);     // have been in big endianness
}

void mesh_sec_get_identity_key(u8 *id_key, u8 *nk)
{
    mesh_sec_func_k1_id (id_key, nk);
}

void mesh_sec_get_beacon_key(u8 *bc_key, u8 *nk)
{
    mesh_sec_func_k1_beacon(bc_key, nk);
}

/*
add crc_rohs

*/
u8 crc8_rohc(u8 *data,u32 len)
{
	unsigned char crc;
	unsigned char i;
	crc = 0xff;
	while(len--)
	{
		crc ^= *data++;
		for(i = 0;i < 8;i++)
		{
		 	if(crc & 0x01)
			{
				crc = (crc >> 1) ^ 0xe0;
			}
			else crc >>= 1;
		   }
		}
	crc = 0xff-crc;
	return crc ;
}
u16 cala_vir_adr_by_uuid(u8 *p_label_uuid)
{
	unsigned char  salt[16];
	unsigned char  hash[16];
	mesh_sec_func_s1m(salt,"vtad");
	tn_aes_cmac (salt, p_label_uuid, 16, hash);
	u16 vir_adr = ((hash[14]<<8)+hash[15])&0x3fff;
	vir_adr|=0x8000;
	return vir_adr;
}

// key encode before save
#if 1
#define KEY_SAVE_ENCODE_NONCE  "TlnkSIGMHY17"

void encode_password_ll(u8 *sk_user, u8 *pd, u32 pd_len, int mic_len)  // pd_len exclude mic
{
    u8 nonce[13] = {KEY_SAVE_ENCODE_NONCE};
    mesh_sec_msg_enc (sk_user, nonce, pd, pd_len, mic_len);
}

int decode_password_ll(u8 *sk_user, u8 *pd, u32 pd_len, int mic_len)  // pd_len include mic
{
    u8 nonce[13] = {KEY_SAVE_ENCODE_NONCE};
    return mesh_sec_msg_dec (sk_user, nonce, pd, pd_len, mic_len);
}
#endif

//-----------------------  Test -----------------------------------------------------
extern int str2hex (char * p);

int test_mesh_sec_key ()
{
	unsigned char AppKey[] = {0x63,0x96,0x47,0x71,0x73,0x4f,0xbd,0x76, 0xe3,0xb4,0x05,0x19,0xd1,0xd9,0x4a,0x48};
	unsigned char NetKey[] = {0x7d,0xd7,0x36,0x4c,0xd8,0x42,0xad,0x18, 0xc1,0x7c,0x2b,0x82,0x0c,0x84,0xc3,0xd6};	
	//unsigned char DevKey[] = {0x9d,0x6d,0xd0,0xe9,0x6e,0xb2,0x5d,0xc1, 0x9a,0x40,0xed,0x99,0x14,0xf8,0xf0,0x3f};

	unsigned char r_aid = 0x14;
	unsigned char r_ek[] = {0x09,0x53,0xfa,0x93,0xe7,0xca,0xac,0x96, 0x38,0xf5,0x88,0x20,0x22,0x0a,0x39,0x8e};
	unsigned char r_pk[] = {0x8b,0x84,0xee,0xde,0xc1,0x00,0x06,0x7d, 0x67,0x09,0x71,0xdd,0x2a,0xa7,0x00,0xcf};
	unsigned char r_e2[] = {0xbe,0x63,0x51,0x05,0x43,0x48,0x59,0xf4, 0x84,0xfc,0x79,0x8e,0x04,0x3c,0xe4,0x0e};
	unsigned char r_p2[] = {0x5d,0x39,0x6d,0x4b,0x54,0xd3,0xcb,0xaf, 0xe9,0x43,0xe0,0x51,0xfe,0x9a,0x4e,0xb8};
	unsigned char r_id[] = {0x84,0x39,0x6c,0x43,0x5a,0xc4,0x85,0x60, 0xb5,0x96,0x53,0x85,0x25,0x3e,0x21,0x0c};
	unsigned char r_bk[] = {0x54,0x23,0xd9,0x67,0xda,0x63,0x9a,0x99, 0xcb,0x02,0x23,0x1a,0x83,0xf7,0xd2,0x54};
	unsigned char r_nid[] = {0x3e,0xca,0xff,0x67,0x2f,0x67,0x33,0x70};

	//01120123450000072f
	unsigned char k2_p[16] = {0, 0x01, 0x12, 0x01, 0x23, 0x45, 0, 0, 0x07, 0x2f};

	unsigned char beacon_m0[32] = {0x02,0x3e,0xca,0xff,0x67,0x2f,0x67, 0x33,0x70,0x12,0x34,0x56,0x79,
					0xc2,0xaf, 0x80,0xad,0x07,0x2a,0x13,0x5c}; 
	int err = 0;
	unsigned char /*salt[16], */r[16], r1[16], r2[16];

	//err = str2hex ("63964771734fbd76e3b40519d1d94a48");
	//err = str2hex ("7dd7364cd842ad18c17c2b820c84c3d6");
	//err = str2hex ("9d6dd0e96eb25dc19a40ed9914f8f03f");

	//err = str2hex ("0953fa93e7caac9638f58820220a398e");
	//err = str2hex ("8b84eedec100067d670971dd2aa700cf");
	
	//err = str2hex ("be635105434859f484fc798e043ce40e");
	//err = str2hex ("5d396d4b54d3cbafe943e051fe9a4eb8");

	//err = str2hex ("84396c435ac48560b5965385253e210c");
	//err = str2hex ("5423d967da639a99cb02231a83f7d254");
	//err = str2hex ("3ecaff672f673370");

	//err = str2hex ("003ecaff672f67337012345678");
	//err = str2hex ("023ecaff672f67337012345679c2af80ad072a135c");
	
	err = mesh_sec_func_k4(r, AppKey);
	err = memcmp (r, &r_aid, 1);if (err) return err;

	err = mesh_sec_func_k2 (r, r1, r2, NetKey, k2_p, 1);
	err = memcmp (r1, &r_ek, 16);if (err) return err;
	err = memcmp (r2, &r_pk, 16);if (err) return err;

	err = mesh_sec_func_k2 (r, r1, r2, NetKey, k2_p + 1, 9);
	err = memcmp (r1, &r_e2, 16);if (err) return err;
	err = memcmp (r2, &r_p2, 16);if (err) return err;

	err = mesh_sec_func_k3(r, NetKey);
	err = memcmp (r, &r_nid, 8);if (err) return err;

	err = mesh_sec_func_k1_id (r, NetKey);
	err = memcmp (r, &r_id, 16);if (err) return err;

	err = mesh_sec_func_k1_beacon (r, NetKey);
	err = memcmp (r, &r_bk, 16);if (err) return err;

	//------------ secure network beacon --------------------------
	memcpy (r, beacon_m0 + 13, 8);
	err = mesh_sec_beacon_auth (r_bk, beacon_m0, 1);if (err) return err;
	memset (beacon_m0 + 13, 0, 8);
	err = mesh_sec_beacon_auth (r_bk, beacon_m0, 0);
	err = memcmp (beacon_m0 + 13, r, 8);if (err) return err;

	return 0;
}
/****************************test how to calculate virtual address ***************/
void test_virtual_address()
{
	unsigned int vir_adr;
	/*
	unsigned char  label_uuid[16]={	0xf4,0xa0,0x02,0xc7,0xfb,0x1e,0x4c,0xa0,
										0xa4,0x69,0xa0,0x21,0xde,0x0d,0xb8,0x75};
										*/
	unsigned char  label_uuid[16]={	0xf4,0xa0,0x02,0xc6,0xfb,0x1e,0x4c,0xa0,
										0xa4,0x69,0xa0,0x21,0xde,0x0d,0xb8,0x75};
	unsigned char  salt[16];
	unsigned char  hash[16];
	mesh_sec_func_s1m(salt,"vtad");
	tn_aes_cmac (salt, label_uuid, 16, hash);
	vir_adr = ((hash[14]<<8)+hash[15])&0x3fff;
	vir_adr|=0x8000;
}
int test_mesh_sec_provision ()
{
	/*
Prov Private Key : 06a516693c9aa31a6084545d0c5db641b48572b97203ddffb7ac73f7d0457663
Prov Public Key : 2c31a47b5779809ef44cb5eaaf5c3e43d5f8faad4a8794cb987e9b03745c78dd
919512183898dfbecd52e2408e43871fd021109117bd3ed4eaf8437743715d4f
Device Private Key : 529aa0670d72cd6497502ed473502b037e8803b5c60829a5a3caa219505530ba
Device Public Key : f465e43ff23d3f1b9dc7dfc04da8758184dbc966204796eccf0d6cf5e16500cc
0201d048bcbbd899eeefc424164e33c201c2b010ca6b4d43a8a155cad8ecb279
Prov ECDH : ab85843a2f6d883f62e5684b38e307335fe6e1945ecd19604105c6f23221eb69
Device ECDH : ab85843a2f6d883f62e5684b38e307335fe6e1945ecd19604105c6f23221eb69
Prov Random : 8b19ac31d58b124c946209b5db1021b9
Device Random : 55a2a2bca04cd32ff6f346bd0a0c1a3a
*/
	int err = 0;
	unsigned char r[16], r1[16];//, r2[16], salt[16];

	unsigned char psk[] = {0x06,0xa5,0x16,0x69,0x3c,0x9a,0xa3,0x1a, 0x60,0x84,0x54,0x5d,0x0c,0x5d,0xb6,0x41,
						   0xb4,0x85,0x72,0xb9,0x72,0x03,0xdd,0xff, 0xb7,0xac,0x73,0xf7,0xd0,0x45,0x76,0x63};

	unsigned char ppk[] = { 0x2c,0x31,0xa4,0x7b,0x57,0x79,0x80,0x9e, 0xf4,0x4c,0xb5,0xea,0xaf,0x5c,0x3e,0x43,
							0xd5,0xf8,0xfa,0xad,0x4a,0x87,0x94,0xcb, 0x98,0x7e,0x9b,0x03,0x74,0x5c,0x78,0xdd,
							0x91,0x95,0x12,0x18,0x38,0x98,0xdf,0xbe, 0xcd,0x52,0xe2,0x40,0x8e,0x43,0x87,0x1f,
							0xd0,0x21,0x10,0x91,0x17,0xbd,0x3e,0xd4, 0xea,0xf8,0x43,0x77,0x43,0x71,0x5d,0x4f};

	unsigned char dsk[] = { 0x52,0x9a,0xa0,0x67,0x0d,0x72,0xcd,0x64, 0x97,0x50,0x2e,0xd4,0x73,0x50,0x2b,0x03,
							0x7e,0x88,0x03,0xb5,0xc6,0x08,0x29,0xa5, 0xa3,0xca,0xa2,0x19,0x50,0x55,0x30,0xba};
	unsigned char dpk[] = { 0xf4,0x65,0xe4,0x3f,0xf2,0x3d,0x3f,0x1b, 0x9d,0xc7,0xdf,0xc0,0x4d,0xa8,0x75,0x81,
							0x84,0xdb,0xc9,0x66,0x20,0x47,0x96,0xec, 0xcf,0x0d,0x6c,0xf5,0xe1,0x65,0x00,0xcc,
							0x02,0x01,0xd0,0x48,0xbc,0xbb,0xd8,0x99, 0xee,0xef,0xc4,0x24,0x16,0x4e,0x33,0xc2,
							0x01,0xc2,0xb0,0x10,0xca,0x6b,0x4d,0x43, 0xa8,0xa1,0x55,0xca,0xd8,0xec,0xb2,0x79};

	unsigned char ecdh[] = {0xab,0x85,0x84,0x3a,0x2f,0x6d,0x88,0x3f, 0x62,0xe5,0x68,0x4b,0x38,0xe3,0x07,0x33,
							0x5f,0xe6,0xe1,0x94,0x5e,0xcd,0x19,0x60, 0x41,0x05,0xc6,0xf2,0x32,0x21,0xeb,0x69};
	unsigned char prn[] = { 0x8b,0x19,0xac,0x31,0xd5,0x8b,0x12,0x4c, 0x94,0x62,0x09,0xb5,0xdb,0x10,0x21,0xb9};
	unsigned char drn[] = { 0x55,0xa2,0xa2,0xbc,0xa0,0x4c,0xd3,0x2f, 0xf6,0xf3,0x46,0xbd,0x0a,0x0c,0x1a,0x3a};

	unsigned char input[] ={0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
							0x00,0x2c,0x31,0xa4,0x7b,0x57,0x79,0x80, 0x9e,0xf4,0x4c,0xb5,0xea,0xaf,0x5c,0x3e,
							0x43,0xd5,0xf8,0xfa,0xad,0x4a,0x87,0x94, 0xcb,0x98,0x7e,0x9b,0x03,0x74,0x5c,0x78,
							0xdd,0x91,0x95,0x12,0x18,0x38,0x98,0xdf, 0xbe,0xcd,0x52,0xe2,0x40,0x8e,0x43,0x87,
							0x1f,0xd0,0x21,0x10,0x91,0x17,0xbd,0x3e, 0xd4,0xea,0xf8,0x43,0x77,0x43,0x71,0x5d,
							0x4f,0xf4,0x65,0xe4,0x3f,0xf2,0x3d,0x3f, 0x1b,0x9d,0xc7,0xdf,0xc0,0x4d,0xa8,0x75,
							0x81,0x84,0xdb,0xc9,0x66,0x20,0x47,0x96, 0xec,0xcf,0x0d,0x6c,0xf5,0xe1,0x65,0x00,
							0xcc,0x02,0x01,0xd0,0x48,0xbc,0xbb,0xd8, 0x99,0xee,0xef,0xc4,0x24,0x16,0x4e,0x33,
							0xc2,0x01,0xc2,0xb0,0x10,0xca,0x6b,0x4d, 0x43,0xa8,0xa1,0x55,0xca,0xd8,0xec,0xb2,
							0x79};

	unsigned char auth[16] = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};

	unsigned char r_salt[] = {0x5f,0xaa,0xbe,0x18,0x73,0x37,0xc7,0x1c, 0xc6,0xc9,0x73,0x36,0x9d,0xca,0xa7,0x9a};
	unsigned char r_ck[16] = {0xe3,0x1f,0xe0,0x46,0xc6,0x8e,0xc3,0x39, 0xc4,0x25,0xfc,0x66,0x29,0xf0,0x33,0x6f};
	unsigned char r_pcfm[16] = {0xb3,0x8a,0x11,0x4d,0xfd,0xca,0x1f,0xe1, 0x53,0xbd,0x2c,0x1e,0x0d,0xc4,0x6a,0xc2};
	unsigned char r_dcfm[16] = {0xee,0xba,0x52,0x1c,0x19,0x6b,0x52,0xcc, 0x2e,0x37,0xaa,0x40,0x32,0x9f,0x55,0x4e};
	unsigned char r_sk[16] = {0xc8,0x02,0x53,0xaf,0x86,0xb3,0x3d,0xfa, 0x45,0x0b,0xbd,0xb2,0xa1,0x91,0xfe,0xa3};
	unsigned char r_sn[16] = {0xda,0x7d,0xdb,0xe7,0x8b,0x5f,0x62,0xb8, 0x1d,0x68,0x47,0x48,0x7e,};
	unsigned char r_dat[40] = {0xef,0xb2,0x25,0x5e,0x64,0x22,0xd3,0x30, 0x08,0x8e,0x09,0xbb,0x01,0x5e,0xd7,0x07,	
							 0x05,0x67,0x00,0x01,0x02,0x03,0x04,0x0b, 0x0c};
	unsigned char r_enc[] = {0xd0,0xbd,0x7f,0x4a,0x89,0xa2,0xff,0x62, 0x22,0xaf,0x59,0xa9,0x0a,0x60,0xad,0x58,
							 0xac,0xfe,0x31,0x23,0x35,0x6f,0x5c,0xec, 0x29};
	unsigned char r_mic[] = {0x73,0xe0,0xec,0x50,0x78,0x3b,0x10,0xc7};
	
	unsigned char r_ecdh[32];

//	err = str2hex ("06a516693c9aa31a6084545d0c5db641b48572b97203ddffb7ac73f7d0457663");
//	err = str2hex ("2c31a47b5779809ef44cb5eaaf5c3e43d5f8faad4a8794cb987e9b03745c78dd");
//	err = str2hex ("919512183898dfbecd52e2408e43871fd021109117bd3ed4eaf8437743715d4f");

//	err = str2hex ("529aa0670d72cd6497502ed473502b037e8803b5c60829a5a3caa219505530ba");
//	err = str2hex ("f465e43ff23d3f1b9dc7dfc04da8758184dbc966204796eccf0d6cf5e16500cc");
//	err = str2hex ("0201d048bcbbd899eeefc424164e33c201c2b010ca6b4d43a8a155cad8ecb279");

	
//	err = str2hex ("ab85843a2f6d883f62e5684b38e307335fe6e1945ecd19604105c6f23221eb69");	//ecdh secret
//	err = str2hex ("8b19ac31d58b124c946209b5db1021b9");		//prov random
//	err = str2hex ("55a2a2bca04cd32ff6f346bd0a0c1a3a");		//device random

//	err = str2hex("00010001000000000000000000000000002c31a47b5779809ef44cb5eaaf5c3e43d5f8faad4a8794cb987e9b03745c78dd919512183898dfbecd52e2408e43871fd021109117bd3ed4eaf8437743715d4ff465e43ff23d3f1b9dc7dfc04da8758184dbc966204796eccf0d6cf5e16500cc0201d048bcbbd899eeefc424164e33c201c2b010ca6b4d43a8a155cad8ecb279");
//	err = str2hex ("5faabe187337c71cc6c973369dcaa79a");		//confirmation salt
//	err = str2hex ("e31fe046c68ec339c425fc6629f0336f");		//conformation key

//	err = str2hex ("b38a114dfdca1fe153bd2c1e0dc46ac2");	//prov confirm
//	err = str2hex ("eeba521c196b52cc2e37aa40329f554e");		//dev confirm
//	err = str2hex ("c80253af86b33dfa450bbdb2a191fea3");		//session key
//	err = str2hex ("da7ddbe78b5f62b81d6847487e");			//session nonce
//	err = str2hex ("efb2255e6422d330088e09bb015ed707056700010203040b0c");	//provision data
//	err = str2hex ("d0bd7f4a89a2ff6222af59a90a60ad58acfe3123356f5cec29");	//provision enc
//	err = str2hex ("73e0ec50783b10c7");						//provision mic

	tn_p256_dhkey (r_ecdh, psk, dpk, dpk + 32);
	err = memcmp (r_ecdh, ecdh, 32);if (err) return err;

	tn_p256_dhkey (r_ecdh, dsk, ppk, ppk + 32);
	err = memcmp (r_ecdh, ecdh, 32);if (err) return err;

	err = mesh_sec_func_s1 (r, input, 145);
	err = memcmp (r, r_salt, 16);if (err) return err;

	err = mesh_sec_prov_confirmation_key (r, input, 145, ecdh);
	err = memcmp (r, r_ck, 16);if (err) return err;

	//provisioner confirmation
	mesh_sec_prov_confirmation (r, input, 145, ecdh, prn, auth);
	err = memcmp (r, r_pcfm, 16);if (err) return err;

	//device confirmation
	mesh_sec_prov_confirmation (r, input, 145, ecdh, drn, auth);
	err = memcmp (r, r_dcfm, 16);if (err) return err;

	//provision session key & session nonce
	mesh_sec_prov_session_key (r, r1, input, 145, ecdh, prn, drn);
	err = memcmp (r, r_sk, 16);if (err) return err;
	err = memcmp (r1 + 3, r_sn, 13);if (err) return err;

	//provision data
	mesh_sec_msg_enc (r_sk, r_sn, r_dat, 25, 8);
	err = memcmp (r_dat, r_enc, 25);if (err) return err;
	err = memcmp (r_mic, r_dat + 25, 8);if (err) return err;

	static u8 A_debug_dev_key[16];
	static u8 provision_salt[16];
	mesh_sec_prov_salt(provision_salt,input,prn,drn);
	mesh_sec_dev_key(A_debug_dev_key,provision_salt,ecdh);

	return 0;
}

int test_mesh_sec_message ()
{
	int err = 0;

	unsigned char r_ek[] =  {0x09,0x53,0xfa,0x93,0xe7,0xca,0xac,0x96, 0x38,0xf5,0x88,0x20,0x22,0x0a,0x39,0x8e};
	unsigned char r_iv[] = {0x12,0x34,0x56,0x78};
	unsigned char r_nn[] =  {0x00,0x80,0x00,0x00,0x01,0x12,0x01,0x00, 0x00,0x12,0x34,0x56,0x78,};
	// r_pdu: ivi/nid, ctl/ttl, seq, src, dest, payload
	unsigned char r_pdu[40] = {0x68,  0x80, 0x00, 0x00, 0x01, 0x12, 0x01, 
		0xff,0xff,0x03,0x4b,0x50,0x05,0x7e,0x40, 0x00,0x00,0x01,0x00,0x00};
	//unsigned char r_epdu[] ={0xb5,0xe7,0xbf,0xda,0xcb,0xaf,0x6c,0xb7, 0xfb,0x6b,0xff,0x87,0x1f};
	//unsigned char r_pdu_mic[] = {0x8a,0x94,0x73,0xc8,0x01,0x8a,0xa6,0x6b};
	unsigned char r_npdu[] = {0x68,0xda,0xe4,0x5b,0x94,0xfb,0x44,0xb5, 0xe7,0xbf,0xda,0xcb,0xaf,0x6c,0xb7,0xfb,
	                          0x6b,0xff,0x87,0x1f,0x8a,0x94,0x73,0xc8, 0x01,0x8a,0xa6,0x6b};
	//unsigned char r_ecdh[32];

	unsigned char r_apl[32] = {0x02,0x23,0x61,0x45,0x63,0x96,0x47,0x71, 0x73,0x4f,0xbd,0x76,0xe3,0xb4,0x05,0x19,
							 0xd1,0xd9,0x4a,0x48, 0, 0, 0, 0};
	unsigned char r_an[] = {NONCE_TYPE_DEVICE,0x00,0x31,0x29,0xab,0x00,0x03,0x12, 0x01,0x12,0x34,0x56,0x78};
	unsigned char r_eapl[] ={0xec,0xe8,0x88,0xaa,0x21,0x69,0x32,0x6d, 0x23,0xf3,0xaf,0xdf,0xcf,0xdc,0x18,0xc5,
							 0x2f,0xde,0xf7,0x72};
	unsigned char r_apl_mic[] = {0x69,0xff,0x44,0x33};

	//unsigned char AppKey[] = {0x63,0x96,0x47,0x71,0x73,0x4f,0xbd,0x76, 0xe3,0xb4,0x05,0x19,0xd1,0xd9,0x4a,0x48};
	//unsigned char NetKey[] = {0x7d,0xd7,0x36,0x4c,0xd8,0x42,0xad,0x18, 0xc1,0x7c,0x2b,0x82,0x0c,0x84,0xc3,0xd6};	
	unsigned char DevKey[] = {0x9d,0x6d,0xd0,0xe9,0x6e,0xb2,0x5d,0xc1, 0x9a,0x40,0xed,0x99,0x14,0xf8,0xf0,0x3f};
	unsigned char PriKey[] = {0x8b,0x84,0xee,0xde,0xc1,0x00,0x06,0x7d, 0x67,0x09,0x71,0xdd,0x2a,0xa7,0x00,0xcf};

	unsigned char r[32];
//	err = str2hex ("0953fa93e7caac9638f58820220a398e");		//encryption key
//	err = str2hex ("00800000011201000012345678");						//tran PDU mic
//	err = str2hex ("ffff034b50057e400000010000");			//tran PDU
//	err = str2hex ("b5e7bfdacbaf6cb7fb6bff871f");			//tran PDU encoded
//	err = str2hex ("8a9473c8018aa66b");						//tran PDU mic 

//	err = str2hex ("0223614563964771734fbd76e3b40519d1d94a48");			//access payload
//	err = str2hex ("02003129ab0003120112345678");						//app nonce
//	err = str2hex ("ece888aa2169326d23f3afdfcfdc18c52fdef772");			//enc payload
//	err = str2hex ("69ff4433");											//enc payload mic
//	err = str2hex ("000000000012345678b5e7bfdacbaf6c");					//random
//	err = str2hex ("68dae45b94fb44b5e7bfdacbaf6cb7fb6bff871f8a9473c8018aa66b");		//network pdu
	//network message

	// 8.3.1: message #1
	//nonce:
	r_nn[0] = NONCE_TYPE_NETWORK;
	memcpy (r_nn + 1, r_pdu + 1, 6);
	r_nn[7] = 0;    // pad
	r_nn[8] = 0;    // pad
	memcpy (r_nn + 9 , r_iv, 4);

	memcpy (r, r_pdu, 20);
	mesh_sec_msg_enc (r_ek, r_nn, r_pdu + 7, 13/*dst+transport pdu*/, 8);	//r_pdu: ivi/nid, ctl/ttl, seq, src, dest, payload
	mesh_sec_msg_obfuscation (PriKey, r_iv, r_pdu + 1);
	
	err = memcmp (r_pdu, r_npdu, 28);if (err) return err;

	mesh_sec_msg_obfuscation (PriKey, r_iv, r_pdu + 1);
	err = mesh_sec_msg_dec (r_ek, r_nn, r_pdu + 7, 21, 8);
	err = memcmp (r_pdu, r, 20);if (err) return err;

	//// 8.3.6 message #6: upper tranport message
	//nonce:
	r_an[0] = NONCE_TYPE_DEVICE;
	r_an[1] = 0;    // pad
	//memcpy (r_an + 2, r_apl + 1, 6);
	//memcpy (r_an + 9 , r_iv, 4);
	
	mesh_sec_msg_enc (DevKey, r_an, r_apl, 20, 4);
	err = memcmp (r_apl, r_eapl, 20);if (err) return err;
	err = memcmp (r_apl_mic, r_apl + 20, 4);if (err) return err;

	err = mesh_sec_msg_dec (DevKey, r_an, r_apl, 24, 4);
	return 0;
}
//-------------------
int test_proxy_config_sec_fun()
{
	//unsigned char  netkey[16]= {0xd1,0xaa,0xfd,0x2a,0x1a,0x3c,0x28,0x1c,0xbd,0xb0,0xe9,0x60,0xed,0xfa,0xd8,0x52};
	unsigned char  encry_key[16] ={0x3a,0x4f,0xe8,0x4a,0x6c,0xc2,0xc6,0xa7,0x66,0xea,0x93,0xf1,0x08,0x4d,0x40,0x39}; 
	unsigned char  Pri_key[16]={0xf6,0x95,0xfc,0xce,0x70,0x9c,0xcf,0xac,0xe4,0xd8,0xb7,0xa1,0xe6,0xe3,0x9d,0x25};
	unsigned char  ivi_idx[4]={0x12,0x34,0x56,0x78};
	static unsigned char proxy_nonce[16];
	static unsigned char r_pdu[40]={0x10,0x80,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00};
	static unsigned char r_pdu_tmp[40];
	proxy_nonce[0]=NONCE_TYPE_PROXY;
	proxy_nonce[1]=0;
	memcpy(proxy_nonce+2,r_pdu+2,5);
	memset(proxy_nonce+7,0,2);
	memcpy(proxy_nonce+9,ivi_idx,4);

	mesh_sec_msg_enc (encry_key, proxy_nonce, r_pdu + 7, 4/*dst+transport pdu*/, 8);
	mesh_sec_msg_obfuscation (Pri_key, ivi_idx, r_pdu + 1);
// proxy config data demo part 
	memcpy(r_pdu_tmp,r_pdu,sizeof(r_pdu));
	mesh_sec_msg_obfuscation (Pri_key, ivi_idx, r_pdu_tmp + 1);
	mesh_sec_msg_dec (encry_key, proxy_nonce, r_pdu_tmp + 7, 12, 8);
	return 1;
}
// test the function of the nodeidentity part adv 
extern u8 aes_ecb_encryption(u8 *key, u8 mStrLen, u8 *mStr, u8 *result);
int test_proxy_adv_with_node_identity()
{
	unsigned char random[8]={0x34,0xae,0x60,0x8f,0xbb,0xc1,0xf2,0xc6};
	unsigned char reslove_key[16]={0x84,0x39,0x6c,0x43,0x5a,0xc4,0x85,0x60,0xb5,0x96,0x53,0x85,0x25,0x3e,0x21,0x0c};
	unsigned char src_adr[2]={0x12,0x01};
	static unsigned char non_hash[16];
	static unsigned char non_para[16];
	memset(non_para,0,6);
	memcpy(non_para+6,random,sizeof(random));
	memcpy(non_para+14,src_adr,sizeof(src_adr));
	#if WIN32 
	#else
	aes_ecb_encryption(reslove_key,sizeof(non_para),non_para,non_hash);
	#endif 
	return 1;
}

int test_mesh_sec_func ()
{
#if 0
	k1 N : 3216d1509884b533248541792b877f98
	k1 SALT : 2ba14ffa0df84a2831938d57d276cab4
	k1 P : 5a09d60797eeb4478aada59db3352a0d
	k1 T : c764bea25cf9738b08956ea3c712d5af
	k1 : f6ed15a8934afbe7d83e8dcb57fcf5d7

k2 N : f7a2a44f8e8a8029064f173ddc1e2b00
k2 P : 00
k2 s1(smk2) : 4f90480c1871bfbffd16971f4d8d10b1
k2 T : 2ea6467aa3378c4c545eda62935b9b86
k2 T0 :
k2 T1 : 82bea685dc2f1deec255ac643741f5ff
k2 T2 : 9f589181a0f50de73c8070c7a6d27f46
k2 T3 : 4c715bd4a64b938f99b453351653124f
NID : 7f
EncryptionKey : 9f589181a0f50de73c8070c7a6d27f46
PrivacyKey : 4c715bd4a64b938f99b453351653124f

LPNAddress : 0203
FriendAddress : 0405
LPNCounter : 0607
FriendCounter : 0809
k2 N : f7a2a44f8e8a8029064f173ddc1e2b00
k2 P : 010203040506070809
k2 s1(smk2) : 4f90480c1871bfbffd16971f4d8d10b1
k2 T : 2ea6467aa3378c4c545eda62935b9b86
k2 T0 :
k2 T1 : 3a6b950f56718c1eab2c600a92d4e9f3
k2 T2 : 11efec0642774992510fb5929646df49
k2 T3 : d4d7cc0dfa772d836a8df9df5510d7a7
NID : 73
EncryptionKey : 11efec0642774992510fb5929646df49
PrivacyKey : d4d7cc0dfa772d836a8df9df5510d7a7

k3 N : f7a2a44f8e8a8029064f173ddc1e2b00
k3 SALT : 0036443503f195cc8a716e136291c302
k3 T : 6da9698c95f500e4edce3bb47f92754f
k3 CMAC(id64|0x01) : 3527c5985f0c05ccff046958233db014
Network ID : ff046958233db014

k4 N : 3216d1509884b533248541792b877f98
k4 SALT : 0e9ac1b7cefa66874c97ee54ac5f49be
k4 T : 62e5d9240cdb3bb0b2743207ea2d6276
k4 CMAC(id5|0x01) : 62e5d9240cdb3bb0b2743207ea2d6276
AID : 01
#endif

	unsigned char AppKey[] = {0x32,0x16,0xd1,0x50,0x98,0x84,0xb5,0x33, 0x24,0x85,0x41,0x79,0x2b,0x87,0x7f,0x98};
	//unsigned char NetKey[] = {0xf7,0xa2,0xa4,0x4f,0x8e,0x8a,0x80,0x29, 0x06,0x4f,0x17,0x3d,0xdc,0x1e,0x2b,0x00};	
	//unsigned char DevKey[] = {0x37,0xc6,0x12,0xc4,0xa2,0xd3,0x37,0xcb, 0x7b,0x98,0x35,0x55,0x31,0xb3,0x61,0x7f};
	unsigned char r_s1[] = {0xb7,0x3c,0xef,0xbd,0x64,0x1e,0xf2,0xea, 0x59,0x8c,0x2b,0x6e,0xfb,0x62,0xf7,0x9c};

	unsigned char k1_n[] = {0x32,0x16,0xd1,0x50,0x98,0x84,0xb5,0x33, 0x24,0x85,0x41,0x79,0x2b,0x87,0x7f,0x98};
	unsigned char k1_s[] = {0x2b,0xa1,0x4f,0xfa,0x0d,0xf8,0x4a,0x28, 0x31,0x93,0x8d,0x57,0xd2,0x76,0xca,0xb4};
	unsigned char k1_p[] = {0x5a,0x09,0xd6,0x07,0x97,0xee,0xb4,0x47, 0x8a,0xad,0xa5,0x9d,0xb3,0x35,0x2a,0x0d};
	//unsigned char k1_t[] = {0xc7,0x64,0xbe,0xa2,0x5c,0xf9,0x73,0x8b, 0x08,0x95,0x6e,0xa3,0xc7,0x12,0xd5,0xaf};
	unsigned char k1_r[] = {0xf6,0xed,0x15,0xa8,0x93,0x4a,0xfb,0xe7, 0xd8,0x3e,0x8d,0xcb,0x57,0xfc,0xf5,0xd7};

	unsigned char k2_n[] = {0xf7,0xa2,0xa4,0x4f,0x8e,0x8a,0x80,0x29, 0x06,0x4f,0x17,0x3d,0xdc,0x1e,0x2b,0x00};
	unsigned char k2_p[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	//unsigned char k2_r[] = {0xf6,0xed,0x15,0xa8,0x93,0x4a,0xfb,0xe7, 0xd8,0x3e,0x8d,0xcb,0x57,0xfc,0xf5,0xd7};

	int err = 0;
	unsigned char salt[16], r[16], r1[16], r2[16];

	//err = str2hex ("f7a2a44f8e8a8029064f173ddc1e2b00");
	
	err = mesh_sec_func_s1m (salt, "test");
	err = memcmp (r_s1, salt, 16);

	err = mesh_sec_func_k1 (r, k1_n, 16, k1_s, k1_p, 16);
	err = memcmp (k1_r, r, 16);

	err = mesh_sec_func_k2 (r, r1, r2, k2_n, k2_p, 1);
	err = mesh_sec_func_k2 (r, r1, r2, k2_n, k2_p + 1, 9);

	err = mesh_sec_func_k3(r, k2_n);

	err = mesh_sec_func_k4(r, AppKey);

	return 0;
}

#if 1 // ONLINE_STATUS_EN
// online status
STATIC_ASSERT((ONLINE_ST_IV_LEN >= 2) && (ONLINE_ST_IV_LEN <= 15));

u8 aes_att_encryption_packet_online_st(u8 *key, u8 *iv, u8 iv_len, u8 *mic, u8 mic_len, u8 *ps, u8 len)
{
    if(iv_len > 15){
        return 0;
    }
    
	u8	e[16], r[16];

	///////////// calculate mic ///////////////////////
	memset (r, 0, 16);
	memcpy (r, iv, iv_len);
	r[iv_len] = len;
	tn_aes_128 (key, r, r);

	for (int i=0; i<len; i++)
	{
		r[i & 15] ^= ps[i];

		if ((i&15) == 15 || i == len - 1)
		{
			tn_aes_128 (key, r, r);
		}
	}
	for (int i=0; i<mic_len; i++)
	{
		mic[i] = r[i];
	}

	///////////////// calculate enc ////////////////////////
	memset (r, 0, 16);
	memcpy (r+1, iv, iv_len);
	for (int i=0; i<len; i++)
	{
		if ((i&15) == 0)
		{
			tn_aes_128 (key, r, e);
			r[0]++;
		}
		ps[i] ^= e[i & 15];
	}

	return 1;
}

u8 aes_att_decryption_packet_online_st(u8 *key, u8 *iv, u8 iv_len, u8 *mic, u8 mic_len, u8 *ps, int ps_len)
{
    if(iv_len > 15){
        return 0;
    }
    
    if(ps_len < 0){
        return 0;   // failed
    }

    u8 len = (u8)ps_len;
    
	u8	e[16], r[16];

	///////////////// calculate enc ////////////////////////
	memset (r, 0, 16);
	memcpy (r+1, iv, iv_len);
	for (int i=0; i<len; i++)
	{
		if ((i&15) == 0)
		{
			tn_aes_128 (key, r, e);
			r[0]++;
		}
		ps[i] ^= e[i & 15];
	}

	///////////// calculate mic ///////////////////////
	memset (r, 0, 16);
	memcpy (r, iv, iv_len);
	r[iv_len] = len;
	tn_aes_128 (key, r, r);

	for (int i=0; i<len; i++)
	{
		r[i & 15] ^= ps[i];

		if ((i&15) == 15 || i == len - 1)
		{
			tn_aes_128 (key, r, r);
		}
	}

	for (int i=0; i<mic_len; i++)
	{
		if (mic[i] != r[i])
		{
			return 0;			//Failed
		}
	}
	return 1;
}

int	online_st_adv_obfuscation (unsigned char key[16], unsigned char* p_data)
{
	int i;
	for (i=0; i<2; i++){
		p_data[i] ^= key[i+8];
	}
	return 0;
}

/*
return: 1 means success, 0 failed.
*/
int online_st_adv_enc_dec (u8 *playload, int enc_flag)
{
	//handle = 0x0a, notification packet (0x1b)
	int success_flag = 0;
	if (!SECURITY_ENABLE)
	{
		return 1;
	}
	
	mesh_cmd_bear_unseg_t *p = GET_BEAR_FROM_ADV_PAYLOAD(playload);
	mesh_net_key_t *p_nk = get_nk_primary();
	if(0 == p_nk){
	    return 0; // should not happen
	}
	u8 *p_iv = &p->len;
    u8 len_mic = ONLINE_ST_MIC_LEN;
    u8 len_iv = ONLINE_ST_IV_LEN;
	int len_data = p->len + sizeof(p->len) - len_iv - len_mic;
	if(len_data < 0){
	    return 0;
	}
    
	u8 len_iv_and_data = (len_data + len_iv); // not include MIC
	
	if(enc_flag){
    	//if((p->len + 1) > (sizeof(mesh_cmd_bear_unseg_t) - OFFSETOF(mesh_cmd_bear_unseg_t,len))){
    	    // return 0; // length error
    	//}
        if(KEY_REFRESH_PHASE2 == p_nk->key_phase){
            p_nk += 1;      // use new key
        }
        
        u8 *key = p_nk->bk;
        p->online_st_adv.nid = p_nk->nid_m;
        p->online_st_adv.nid2 = p_nk->bk[0]&1;
        success_flag = aes_att_encryption_packet_online_st(key, p_iv, len_iv, p_iv+len_iv_and_data, len_mic, p_iv+len_iv, len_data);
        online_st_adv_obfuscation(key, p->online_st_adv.data);
	}else{
        mesh_cmd_bear_unseg_t br_temp;
        if(p_nk[1].valid){  // new key
            memcpy(&br_temp, p, sizeof(br_temp));
        }
	    foreach(i,2){
	        online_st_adv_t *p_st = &p->online_st_adv;
	        mesh_net_key_t *p_nk_dec = &p_nk[i];
	        if((p_st->nid == p_nk_dec->nid_m) && (p_st->nid2 == (p_nk_dec->bk[0]&1)) && p_nk_dec->valid){
	            if(1 == i){
                    memcpy(&p->len, &br_temp.len, p->len+1);    // restore
	            }
                u8 *key = p_nk_dec->bk;
                online_st_adv_obfuscation(key, p->online_st_adv.data);
                // parameters is same with encode
                success_flag = aes_att_decryption_packet_online_st(key, p_iv, len_iv, p_iv+len_iv_and_data, len_mic, p_iv+len_iv, len_data);
                if(success_flag){
                    break;
                }
            }
        }
	}
	return success_flag;
}

int online_st_gatt_enc_dec (u8 *report, u8 len, int enc_flag)
{
	//handle = 0x0a, notification packet (0x1b)
	int success_flag = 0;
	if (!SECURITY_ENABLE)
	{
		return 1;
	}

	online_st_report_t *p_report = (online_st_report_t *)report;
	mesh_net_key_t *p_nk = get_nk_primary();
	if(0 == p_nk){
	    return 0; // should not happen
	}
	u8 *p_iv = (u8 *)p_report;
    u8 len_mic = ONLINE_ST_MIC_LEN_GATT;
    u8 len_iv = ONLINE_ST_IV_LEN_GATT;
	int len_data = len - len_iv - len_mic;
	if(len_data < 0){
	    return 0;
	}
	
	u8 len_iv_and_data = (len_data + len_iv); // not include MIC
	
	if(enc_flag){
        if(KEY_REFRESH_PHASE2 == p_nk->key_phase){
            p_nk += 1;      // use new key
        }
        
        u8 *key = p_nk->bk;
        success_flag = aes_att_encryption_packet_online_st(key, p_iv, len_iv, p_iv+len_iv_and_data, len_mic, p_iv+len_iv, len_data);
	}else{
        online_st_report_t report_temp;
        if(p_nk[1].valid){  // new key
            memcpy(&report_temp, p_report, sizeof(report_temp));
        }
	    foreach(i,2){
	        mesh_net_key_t *p_nk_dec = &p_nk[i];
	        if(p_nk_dec->valid){
	            if(1 == i){
                    memcpy(p_report, &report_temp, len);    // restore
	            }
                u8 *key = p_nk_dec->bk;
                // parameters is same with encode
                success_flag = aes_att_decryption_packet_online_st(key, p_iv, len_iv, p_iv+len_iv_and_data, len_mic, p_iv+len_iv, len_data);
                if(success_flag){
                    break;
                }
            }
        }
	}
	return success_flag;
}

int online_st_adv_enc (u8 *playload)
{
    return online_st_adv_enc_dec(playload, 1);
}

int online_st_adv_dec (u8 *playload)
{
    return online_st_adv_enc_dec(playload, 0);
}

int online_st_gatt_enc (u8 *report, u8 len)
{
    return online_st_gatt_enc_dec(report, len, 1);
}

int online_st_gatt_dec (u8 *report, u8 len)
{
    // FOR app, so 0 means success
    if(1 == online_st_gatt_enc_dec(report, len, 0)){
        return 0;
    }else{
        return -1;
    }
}

#if 0
void fun_test()
{
    static mesh_cmd_bear_unseg_t A_pkt = {0, 0x1e, 0x62};
    A_pkt.online_st_adv.data[0] = 0x99;
    static mesh_cmd_bear_unseg_t A_pkt1 = {0};
    memcpy(&A_pkt1,&A_pkt, sizeof(mesh_cmd_bear_unseg_t));
    online_st_adv_enc((u8 *)&A_pkt1.len);
    static mesh_cmd_bear_unseg_t A_pkt2 = {0};
    memcpy(&A_pkt2,&A_pkt1, sizeof(mesh_cmd_bear_unseg_t));
    static int A_pkt_ret;
    A_pkt_ret = online_st_adv_dec((u8 *)&A_pkt2.len);
    
    static u8 A_4buf[16] = {0x99};
    static u8 A_4buf1[2][16] = {{0}};
    #if !WIN32
	u8 key[16] = {1};
	void aes_att_encryption (unsigned char *key, unsigned char *plaintext, unsigned char *result);
    aes_att_encryption (key, A_4buf, A_4buf1[0]);
    tn_aes_128 (key, A_4buf, A_4buf1[1]);
    #endif

    static online_st_report_t report = {1};
    static online_st_report_t report2 = {0};
    memcpy(&report2,&report,sizeof(report2));
    online_st_gatt_enc((u8 *)&report2, sizeof(report));
    static online_st_report_t report3 = {0};
    memcpy(&report3,&report2,sizeof(report3));
    online_st_gatt_dec((u8 *)&report3, sizeof(report));
}
#endif
#endif

