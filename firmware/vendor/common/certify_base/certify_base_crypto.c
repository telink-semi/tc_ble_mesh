/********************************************************************************************************
 * @file	certify_base_crypto.c
 *
 * @brief	for TLSR chips
 *
 * @author	telink
 * @date	Sep. 30, 2010
 *
 * @par     Copyright (c) 2017, Telink Semiconductor (Shanghai) Co., Ltd. ("TELINK")
 *          All rights reserved.
 *
 *          Licensed under the Apache License, Version 2.0 (the "License");
 *          you may not use this file except in compliance with the License.
 *          You may obtain a copy of the License at
 *
 *              http://www.apache.org/licenses/LICENSE-2.0
 *
 *          Unless required by applicable law or agreed to in writing, software
 *          distributed under the License is distributed on an "AS IS" BASIS,
 *          WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *          See the License for the specific language governing permissions and
 *          limitations under the License.
 *
 *******************************************************************************************************/
#include "proj_lib/ble/blt_config.h"
#include "../user_config.h"
#include "proj_lib/sig_mesh/app_mesh.h"
#include "proj_lib/mesh_crypto/sha256_telink.h"
//#include "sha1_telink.h"
#include "certify_base_crypto.h"
//#include "pem_der.h"
//#include "asn_telink.h"

#if CERTIFY_BASE_ENABLE // for the test case ,it should disable EPA
int mbedtls_crt_pem2der_define(const unsigned char *pem, size_t pem_sz,unsigned char *der_buf, size_t buf_sz,const char* start,const char* end);
int mbedtls_crt_parse_dev_cert(const unsigned char* crt, u32 crt_sz, dev_cert_tbs_part_t* msc_crt);

char uri_base[]=" //ptswebapiprod.azurewebsites.net/api/meshcert/v/b";

#define MAX_CERT_ITEM_CNT	2
cert_item_t cert_item[MAX_CERT_ITEM_CNT];

#define CERTIFY_OOB_BY_DEFAULT_CERT			1 // use default certificate //check by the rootcert ,and it will not have the oob part
#define CERTIFY_OOB_BY_READING_FLASH		2 // reading certificate from flash.

#if WIN32 // sig_mesh_tool.exe
#define CERTIFY_TYPE  CERTIFY_OOB_BY_DEFAULT_CERT // must 1. because it is for sig_mesh_tool.exe
#else
#define CERTIFY_TYPE  CERTIFY_OOB_BY_READING_FLASH // CERTIFY_OOB_BY_DEFAULT_CERT
#endif

#if(CERTIFY_TYPE == CERTIFY_OOB_BY_DEFAULT_CERT)
const u8 device_cert[] = {
		0x30,0x82,0x02,0xC9,0x30,0x82,0x02,0x70,0xA0,0x03,0x02,0x01,0x02,0x02,0x14,0x11,0xF6,0xFE,0xA9,0x93,0xAF,0xF6,0x2F,0xC3,0x6C,0xE3,0xFE,0x31,0xDF,0x6F,0xB4,0xA1,
		0x2B,0xB2,0xDE,0x30,0x0A,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x04,0x03,0x02,0x30,0x81,0x9E,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x43,0x4E,0x31,
		0x11,0x30,0x0F,0x06,0x03,0x55,0x04,0x08,0x0C,0x08,0x53,0x68,0x61,0x6E,0x67,0x48,0x61,0x69,0x31,0x14,0x30,0x12,0x06,0x03,0x55,0x04,0x0A,0x0C,0x0B,0x54,0x65,0x6C,
		0x69,0x6E,0x6B,0x2D,0x53,0x65,0x6D,0x69,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04,0x0B,0x0C,0x06,0x54,0x65,0x6C,0x69,0x6E,0x6B,0x31,0x2D,0x30,0x2B,0x06,0x03,0x55,
		0x04,0x03,0x0C,0x24,0x30,0x30,0x31,0x42,0x44,0x43,0x30,0x38,0x2D,0x31,0x30,0x32,0x31,0x2D,0x30,0x42,0x30,0x45,0x2D,0x30,0x41,0x30,0x43,0x2D,0x30,0x30,0x30,0x42,
		0x30,0x45,0x30,0x41,0x30,0x43,0x30,0x30,0x31,0x26,0x30,0x24,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x01,0x16,0x17,0x73,0x75,0x70,0x70,0x6F,0x72,0x74,
		0x40,0x74,0x65,0x6C,0x69,0x6E,0x6B,0x2D,0x73,0x65,0x6D,0x69,0x2E,0x63,0x6F,0x6D,0x30,0x1E,0x17,0x0D,0x32,0x33,0x31,0x30,0x31,0x31,0x30,0x36,0x30,0x31,0x33,0x34,
		0x5A,0x17,0x0D,0x33,0x33,0x31,0x30,0x30,0x38,0x30,0x36,0x30,0x31,0x33,0x34,0x5A,0x30,0x81,0xB2,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x43,0x4E,
		0x31,0x11,0x30,0x0F,0x06,0x03,0x55,0x04,0x08,0x0C,0x08,0x53,0x68,0x61,0x6E,0x67,0x48,0x61,0x69,0x31,0x14,0x30,0x12,0x06,0x03,0x55,0x04,0x0A,0x0C,0x0B,0x54,0x65,
		0x6C,0x69,0x6E,0x6B,0x2D,0x53,0x65,0x6D,0x69,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04,0x0B,0x0C,0x06,0x54,0x65,0x6C,0x69,0x6E,0x6B,0x31,0x41,0x30,0x3F,0x06,0x03,
		0x55,0x04,0x03,0x0C,0x38,0x30,0x30,0x31,0x42,0x44,0x43,0x30,0x38,0x2D,0x31,0x30,0x32,0x31,0x2D,0x30,0x42,0x30,0x45,0x2D,0x30,0x41,0x30,0x43,0x2D,0x30,0x30,0x30,
		0x42,0x30,0x45,0x30,0x41,0x30,0x43,0x30,0x30,0x20,0x42,0x43,0x49,0x44,0x3A,0x30,0x32,0x31,0x31,0x20,0x42,0x50,0x49,0x44,0x3A,0x30,0x30,0x30,0x31,0x31,0x26,0x30,
		0x24,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x01,0x16,0x17,0x73,0x75,0x70,0x70,0x6F,0x72,0x74,0x40,0x74,0x65,0x6C,0x69,0x6E,0x6B,0x2D,0x73,0x65,0x6D,
		0x69,0x2E,0x63,0x6F,0x6D,0x30,0x59,0x30,0x13,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07,0x03,0x42,0x00,0x04,
		0xC8,0x1A,0x89,0x16,0xB6,0x66,0x90,0xAE,0x74,0x46,0xC7,0xF2,0x83,0x6A,0xA4,0xC8,0x2F,0x10,0x57,0xED,0x8C,0x80,0x46,0x89,0xFA,0x12,0x7D,0xE8,0xB6,0x11,0xA5,0xFE,
		0x4C,0xB9,0xEE,0x73,0xE2,0xC1,0xC3,0x9B,0x62,0x0A,0xDB,0xED,0x66,0x8B,0xEE,0x3E,0x42,0x4A,0x4C,0x63,0xD1,0x39,0x53,0xC6,0x3C,0x80,0xB1,0x9D,0xB9,0xD6,0xD8,0x21,
		0xA3,0x76,0x30,0x74,0x30,0x1F,0x06,0x03,0x55,0x1D,0x23,0x04,0x18,0x30,0x16,0x80,0x14,0x59,0xE3,0x7F,0xF8,0x34,0x3E,0x69,0x40,0x63,0x5A,0x90,0x7B,0xF4,0xCA,0xA0,
		0xA6,0xBF,0x1E,0xE6,0xE9,0x30,0x1D,0x06,0x03,0x55,0x1D,0x0E,0x04,0x16,0x04,0x14,0x01,0xB9,0x63,0xC4,0xDC,0x8F,0xB1,0x7F,0x1F,0x4A,0x6D,0xB1,0xD5,0x78,0x32,0x44,
		0x12,0xF8,0x8A,0x68,0x30,0x09,0x06,0x03,0x55,0x1D,0x13,0x04,0x02,0x30,0x00,0x30,0x0B,0x06,0x03,0x55,0x1D,0x0F,0x04,0x04,0x03,0x02,0x01,0x06,0x30,0x1A,0x06,0x03,
		0x55,0x1D,0x20,0x01,0x01,0xFF,0x04,0x10,0x30,0x0E,0x30,0x0C,0x06,0x0A,0x60,0x86,0x48,0x01,0x65,0x03,0x02,0x01,0x30,0x01,0x30,0x0A,0x06,0x08,0x2A,0x86,0x48,0xCE,
		0x3D,0x04,0x03,0x02,0x03,0x47,0x00,0x30,0x44,0x02,0x20,0x4C,0x46,0x85,0xE2,0x6C,0xD2,0x4E,0x9E,0x5C,0xA6,0x11,0x78,0xCE,0x84,0xA4,0xE3,0x07,0xBF,0x87,0x95,0x28,
		0x14,0x39,0x6F,0x05,0x11,0x1F,0x06,0xEC,0x05,0x20,0x20,0x02,0x20,0x05,0x0C,0x45,0x48,0x81,0x54,0x36,0x64,0x96,0x26,0x48,0xD5,0x82,0x56,0x00,0x10,0x73,0x55,0x34,
		0xF0,0xFB,0xAE,0xE7,0x71,0x0D,0x39,0x85,0x5E,0xCE,0x85,0x54,0xED
};

const u8 inter_midate_cert[] = {
		0x30,0x82,0x02,0x9C,0x30,0x82,0x02,0x43,0xA0,0x03,0x02,0x01,0x02,0x02,0x14,0x2B,0xC7,0x6C,0x6F,0x20,0x8B,0xC9,0xF6,0x01,0xEC,0xB4,0x63,0x97,0xA7,0x1D,0xA1,0xB0,
		0xF2,0xBA,0x75,0x30,0x0A,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x04,0x03,0x02,0x30,0x81,0x9E,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x43,0x4E,0x31,
		0x11,0x30,0x0F,0x06,0x03,0x55,0x04,0x08,0x0C,0x08,0x53,0x68,0x61,0x6E,0x67,0x48,0x61,0x69,0x31,0x14,0x30,0x12,0x06,0x03,0x55,0x04,0x0A,0x0C,0x0B,0x54,0x65,0x6C,
		0x69,0x6E,0x6B,0x2D,0x53,0x65,0x6D,0x69,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04,0x0B,0x0C,0x06,0x54,0x65,0x6C,0x69,0x6E,0x6B,0x31,0x2D,0x30,0x2B,0x06,0x03,0x55,
		0x04,0x03,0x0C,0x24,0x30,0x30,0x31,0x42,0x44,0x43,0x30,0x38,0x2D,0x31,0x30,0x32,0x31,0x2D,0x30,0x42,0x30,0x45,0x2D,0x30,0x41,0x30,0x43,0x2D,0x30,0x30,0x30,0x42,
		0x30,0x45,0x30,0x41,0x30,0x43,0x30,0x30,0x31,0x26,0x30,0x24,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x01,0x16,0x17,0x73,0x75,0x70,0x70,0x6F,0x72,0x74,
		0x40,0x74,0x65,0x6C,0x69,0x6E,0x6B,0x2D,0x73,0x65,0x6D,0x69,0x2E,0x63,0x6F,0x6D,0x30,0x1E,0x17,0x0D,0x32,0x33,0x31,0x30,0x31,0x31,0x30,0x36,0x30,0x31,0x32,0x31,
		0x5A,0x17,0x0D,0x33,0x33,0x31,0x30,0x30,0x38,0x30,0x36,0x30,0x31,0x32,0x31,0x5A,0x30,0x81,0x9E,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x43,0x4E,
		0x31,0x11,0x30,0x0F,0x06,0x03,0x55,0x04,0x08,0x0C,0x08,0x53,0x68,0x61,0x6E,0x67,0x48,0x61,0x69,0x31,0x14,0x30,0x12,0x06,0x03,0x55,0x04,0x0A,0x0C,0x0B,0x54,0x65,
		0x6C,0x69,0x6E,0x6B,0x2D,0x53,0x65,0x6D,0x69,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04,0x0B,0x0C,0x06,0x54,0x65,0x6C,0x69,0x6E,0x6B,0x31,0x2D,0x30,0x2B,0x06,0x03,
		0x55,0x04,0x03,0x0C,0x24,0x30,0x30,0x31,0x42,0x44,0x43,0x30,0x38,0x2D,0x31,0x30,0x32,0x31,0x2D,0x30,0x42,0x30,0x45,0x2D,0x30,0x41,0x30,0x43,0x2D,0x30,0x30,0x30,
		0x42,0x30,0x45,0x30,0x41,0x30,0x43,0x30,0x30,0x31,0x26,0x30,0x24,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x01,0x16,0x17,0x73,0x75,0x70,0x70,0x6F,0x72,
		0x74,0x40,0x74,0x65,0x6C,0x69,0x6E,0x6B,0x2D,0x73,0x65,0x6D,0x69,0x2E,0x63,0x6F,0x6D,0x30,0x59,0x30,0x13,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,0x06,0x08,
		0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07,0x03,0x42,0x00,0x04,0x96,0x2B,0x48,0x65,0xC0,0xC7,0xD4,0x53,0x27,0xC5,0x0B,0x23,0xBA,0x11,0x54,0x56,0xD2,0xFE,0xCB,0xF2,
		0xB1,0x5D,0x68,0xC9,0xD6,0x83,0x15,0xA0,0x00,0x9E,0x8E,0xD3,0x11,0xDC,0x7F,0xAD,0x24,0x47,0xCA,0xDB,0x05,0x3B,0xF4,0x5E,0x8D,0xB3,0xBF,0xA4,0x82,0x93,0x4A,0x19,
		0xEF,0xAD,0xD9,0xCA,0x27,0xE7,0x16,0xA9,0x75,0xE6,0x5D,0xD3,0xA3,0x5D,0x30,0x5B,0x30,0x1F,0x06,0x03,0x55,0x1D,0x23,0x04,0x18,0x30,0x16,0x80,0x14,0x3C,0x62,0xD1,
		0x96,0xF6,0x6D,0x33,0x7D,0x40,0xCC,0x78,0x26,0x51,0x8C,0x1A,0xF2,0x2F,0x42,0x5D,0x3B,0x30,0x1D,0x06,0x03,0x55,0x1D,0x0E,0x04,0x16,0x04,0x14,0x59,0xE3,0x7F,0xF8,
		0x34,0x3E,0x69,0x40,0x63,0x5A,0x90,0x7B,0xF4,0xCA,0xA0,0xA6,0xBF,0x1E,0xE6,0xE9,0x30,0x0C,0x06,0x03,0x55,0x1D,0x13,0x04,0x05,0x30,0x03,0x01,0x01,0xFF,0x30,0x0B,
		0x06,0x03,0x55,0x1D,0x0F,0x04,0x04,0x03,0x02,0x01,0x06,0x30,0x0A,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x04,0x03,0x02,0x03,0x47,0x00,0x30,0x44,0x02,0x20,0x3D,0x64,
		0x47,0x11,0x77,0xDD,0xE2,0x6A,0xA7,0x02,0x69,0xDB,0x76,0x08,0x8C,0xAC,0xD0,0x9A,0x8D,0xCF,0xD3,0x15,0x57,0xD3,0x40,0x72,0xE7,0xC0,0xFB,0xA6,0x12,0xBE,0x02,0x20,
		0x42,0xCB,0x21,0x88,0xF7,0x72,0xE9,0x90,0x3C,0x61,0xDE,0x4C,0xB3,0xC9,0x1B,0x04,0x5C,0x6D,0x0E,0x03,0x67,0xC2,0xF2,0x39,0x82,0x2A,0xC1,0xEF,0xFD,0xA9,0x1E,0x19
};

const u8 cert_pub_key[64] = {	
		0xc8,0x1a,0x89,0x16,0xb6,0x66,0x90,0xae,0x74,0x46,0xc7,0xf2,0x83,0x6a,0xa4,0xc8,
		0x2f,0x10,0x57,0xed,0x8c,0x80,0x46,0x89,0xfa,0x12,0x7d,0xe8,0xb6,0x11,0xa5,0xfe,
		0x4c,0xb9,0xee,0x73,0xe2,0xc1,0xc3,0x9b,0x62,0x0a,0xdb,0xed,0x66,0x8b,0xee,0x3e,
		0x42,0x4a,0x4c,0x63,0xd1,0x39,0x53,0xc6,0x3c,0x80,0xb1,0x9d,0xb9,0xd6,0xd8,0x21
};

// should get the private key part .
const u8 cert_private_key[32] = {	
		0x38,0xf5,0x28,0xfd,0xc3,0x07,0xc5,0x6b,0x9e,0x8e,0xb9,0x6e,0x9d,0xa2,0xcf,0x63,
		0xa9,0x85,0x1f,0x49,0x46,0x29,0xb0,0x4c,0xf2,0xc9,0x14,0x33,0x9d,0x8d,0xae,0x0f
};

const u8 cert_uuid[16]= {	
		0x00,0x1B,0xDC,0x08,0x10,0x21,0x0B,0x0E,
		0x0A,0x0C,0x00,0x0B,0x0E,0x0A,0x0C,0x00
};

const u8 cert_oob[32] = {0};

#elif (CERTIFY_TYPE == CERTIFY_OOB_BY_READING_FLASH)
const u8 * device_cert;
u32 device_cert_len;
const u8 * inter_midate_cert;
u32 inter_cert_len;
u32 cert_pub_key_adr;//64
u32 cert_pri_key_adr;//32
u32 cert_uuid_adr;//16
u32 cert_oob_adr;//32
u16 cert_crc;
u32 cert_valid_flag = CERT_VALID_FLAG;
u16 cert_calc;

u8 cert_valid()
{
	u32 flag_flash ;
	flash_read_page(FLASH_ADR_CERTIFY_ADR+CERT_VALID_OFFSET, 4, (u8*)(&flag_flash));
	if(flag_flash == CERT_VALID_FLAG){
		// cert is valid 
		return CERT_IS_VALID;
	}else if (flag_flash == 0xffffffff){
		//cert need to verify 
		const u8 *p_cert = (const u8 *)(FLASH_R_BASE_ADDR + FLASH_ADR_CERTIFY_ADR);
		flash_read_page(FLASH_ADR_CERTIFY_ADR+CERT_CRC_OFFSET, 2, (u8*)(&cert_crc));
		cert_calc = crc16(p_cert, CERT_CRC_OFFSET);
		if(cert_crc != cert_calc){
			// cert is invalid 
			return CERT_IS_INVALID_UNPROV;
		}
		flash_write_page(FLASH_ADR_CERTIFY_ADR+CERT_VALID_OFFSET, 4, (u8*)(&cert_valid_flag));
		return CERT_IS_VALID;
	}else{
		// cert valid flag is invalid 
		if(is_provision_success()){
			return CERT_IS_INVALID_PROV;
		}else{
			return CERT_IS_INVALID_UNPROV;
		}
	}
}


void cert_init()
{
	if( cert_valid() == CERT_IS_VALID){
		flash_read_page(FLASH_ADR_CERTIFY_ADR+CERT_DEVICE_CERT_OFFSET, 4, (u8*)(&device_cert_len));
		device_cert = (const u8 *)(FLASH_ADR_CERTIFY_ADR+CERT_DEVICE_CERT_OFFSET+4);
		flash_read_page(FLASH_ADR_CERTIFY_ADR+CERT_INTER_CERT_OFFSET, 4, (u8*)(&inter_cert_len));
		inter_midate_cert = (const u8 *)(FLASH_ADR_CERTIFY_ADR+CERT_INTER_CERT_OFFSET+4);
		cert_pub_key_adr = (FLASH_ADR_CERTIFY_ADR+CERT_PUBKEY_OFFSET);
		cert_pri_key_adr = (FLASH_ADR_CERTIFY_ADR+CERT_PRIVATE_OFFSET);
		cert_uuid_adr = (FLASH_ADR_CERTIFY_ADR+CERT_UUID_OFFSET);
		cert_oob_adr = (FLASH_ADR_CERTIFY_ADR+CERT_STATIC_OOB_OFFSET);
	}else {// if the cert is invalid ,still can read the uuid and oob
		cert_uuid_adr = (FLASH_ADR_CERTIFY_ADR+CERT_UUID_OFFSET);
		cert_oob_adr = (FLASH_ADR_CERTIFY_ADR+CERT_STATIC_OOB_OFFSET);
	}	
}
#endif

void cert_set_uuid(u8 *p_uuid)
{
#if(CERTIFY_TYPE == CERTIFY_OOB_BY_DEFAULT_CERT)
	memcpy(p_uuid,cert_uuid,sizeof(cert_uuid));
#elif(CERTIFY_TYPE == CERTIFY_OOB_BY_READING_FLASH)
	cert_uuid_adr = (FLASH_ADR_CERTIFY_ADR+CERT_UUID_OFFSET);
	flash_read_page(cert_uuid_adr, 16, p_uuid);
#endif
}

void cert_item_init(u8 en)
{
	if(en){
		#if(CERTIFY_TYPE == CERTIFY_OOB_BY_DEFAULT_CERT)
			
			#if URI_ENABLE //suit to BV-01C BV-02C, BI-01c 
		uri_base[0]=0x17;
		cert_item[0].id =0;
		cert_item[0].p_item = (const char*)uri_base;
		cert_item[0].len = sizeof(uri_base);
		cert_item[1].id =1;
		cert_item[1].p_item = (char*)device_cert;
		cert_item[1].len =sizeof(device_cert);
			#else//suit to BV-03C BV-04C
		cert_item[0].id =1;
		cert_item[0].p_item = (char*)device_cert;
		cert_item[0].len =sizeof(device_cert);
		cert_item[1].id =2;
		cert_item[1].p_item = (const char*)inter_midate_cert;
		cert_item[1].len = sizeof(inter_midate_cert);
			#endif
		#elif (CERTIFY_TYPE == CERTIFY_OOB_BY_READING_FLASH)
			#if URI_ENABLE //suit to BV-01C BV-02C, BI-01c 
		uri_base[0]=0x17;
		cert_item[0].id =0;
		cert_item[0].p_item = (const char*)uri_base;
		cert_item[0].len = sizeof(uri_base);
		cert_item[1].id =1;
		cert_item[1].p_item = (char*)device_cert;
		cert_item[1].len = device_cert_len;
			#else
		cert_item[0].id =1;
		cert_item[0].p_item = (char*)device_cert;
		cert_item[0].len = device_cert_len;
		cert_item[1].id =2;
		cert_item[1].p_item = (const char*)inter_midate_cert;
		cert_item[1].len = inter_cert_len;
			#endif
		#endif
	}else{
		cert_item[0].len =0;
		cert_item[0].len =0;
	}
}

int cert_item_rsp(u16 id,u16 offset,u16 max_size,u8 *p_buf,u16 *p_len)
{
	cert_item_t *p_cert;
	int i=0;
	for(i=0;i<MAX_CERT_ITEM_CNT;i++){
		p_cert = cert_item+i;
		if(p_cert->id == id){
			break;
		}
	}
	if(i == MAX_CERT_ITEM_CNT){
		return -1;
	}
	if(offset > p_cert->len){
		return -2;
	}
	if(p_cert->len >= (offset+max_size)){
		*p_len = max_size;
	}else{
		*p_len = p_cert->len - offset;
	}
	memcpy(p_buf,(u8 *)(FLASH_R_BASE_ADDR + p_cert->p_item + offset),*p_len);
	return 0;
}


u32  use_cert_id_get_len(u8 id)
{
	for(u32 i=0;i<MAX_CERT_ITEM_CNT;i++){
		cert_item_t *p_cert = &(cert_item[i]);
		if(p_cert->id == id){
			return p_cert->len;
		}
	}
	return 0;
}



/**
 * @brief       This function server to get number of certificates.
 * @param[in]   p_id- pointer of certify item list.
 * @return      number of certificates.
 * @note        
 */
u32 cert_id_get(u16 *p_id)
{
	u32 cnt =0;
	for(u32 i=0;i<MAX_CERT_ITEM_CNT;i++){
		cert_item_t *p_cert = cert_item+i;
		if(p_cert->len){
			*(p_id+i) = p_cert->id;
			++cnt;
		}
	}
	
	return cnt;
}


void get_cert_id_list(u8 *p_list,u32 *p_len)
{
	u32 idx =0;
	foreach_arr(i,cert_item){
		cert_item_t *p_cert = cert_item+i;
		if(p_cert->len){
			p_list[idx] = p_cert->id & 0xff;
			p_list[idx+1] = (p_cert->id >>8)&0xff;
			idx+=2;
		}
	}
	*p_len = idx;
}

const char * get_cert_content_by_id(u16 id,u32* p_len)
{
	foreach_arr(i,cert_item){
		cert_item_t *p_cert = cert_item+i;
		if(p_cert->len && p_cert->id == id){
			* p_len = p_cert->len;
			return p_cert->p_item;
		}
	}
	return NULL;
}

#if 0
u8 cert_info_check_pubkey_info(u8 *pubkey,u8* key_info)
{
	u8 sha1out[20];
	u8 len;
	if(pubkey[0]==4){
		len =65;
	}else{
		len =33;
	}
	mbedtls_sha1((const u8 *) pubkey,len,sha1out); // src: 7b4ef9b898ecee25bb895d73c7c431df71c3a47b // 20231124
	if(!memcmp(sha1out,key_info,sizeof(sha1out))){
		return 1;
	}else{
		return 0;
	}
}
#endif

static private_cert_str_t private_cert_dat;

int cert_info_parse_init()
{
#if (CERTIFY_TYPE == CERTIFY_OOB_BY_DEFAULT_CERT )
	private_cert_dat.pri.len = sizeof(cert_private_key);
	memcpy(private_cert_dat.pri.key,cert_private_key,sizeof(cert_private_key));
	private_cert_dat.pub.len = sizeof(cert_pub_key);
	memcpy(private_cert_dat.pub.key+1,cert_pub_key,sizeof(cert_pub_key));
	private_cert_dat.val=2;
#elif (CERTIFY_TYPE == CERTIFY_OOB_BY_READING_FLASH )
	private_cert_dat.pri.len = 32;
	flash_read_page(cert_pri_key_adr, private_cert_dat.pri.len, private_cert_dat.pri.key);
	private_cert_dat.pub.len = 64;
	flash_read_page(cert_pub_key_adr, private_cert_dat.pub.len, private_cert_dat.pub.key+1);
	private_cert_dat.val=2;
#endif
	return 0;
}

int  cert_base_func_init()
{
	#if (CERTIFY_TYPE == CERTIFY_OOB_BY_READING_FLASH )
		// need to init the cert first 
		cert_init();
	#endif
	if(cert_info_parse_init()==0){
		// check pass , need to set the pubkey and privatekey ,and then init the record list .
		cert_item_init(1);
		return 1;
	}else{
		// certify useless, use the normal mode ,and not support the record id 
		cert_item_init(0);
	}
	return 0;
}

void cert_base_oob_set()
{
	#if (CERTIFY_TYPE == CERTIFY_OOB_BY_DEFAULT_CERT)
	// and set the static oob part
	if(is_buf_zero(cert_oob,sizeof(cert_oob)))	{
		// no oob mode 
		set_node_prov_para_pubkey_no_oob();
	}else{
		// static oob mode 
		memcpy(dev_auth, cert_oob, 32);
		set_node_prov_para_pubkey_static_oob();
	}
	#elif (CERTIFY_TYPE == CERTIFY_OOB_BY_READING_FLASH)
	u8 oob[32];
	flash_read_page(cert_oob_adr, sizeof(oob), oob);
	if(is_buf_all_one(oob,sizeof(oob))){
		// oob is empty 
		set_node_prov_para_pubkey_no_oob();
	}else{
		// static oob ,need to set static oob 
		memcpy(dev_auth, oob, 32);
		set_node_prov_para_pubkey_static_oob();
	}
	#else
	set_node_prov_para_pubkey_no_oob();
	#endif
}

void cert_base_set_key(u8 *pk,u8 *sk)
{
	u8 *cert_pk = private_cert_dat.pub.key+1;
	u8 *cert_sk = private_cert_dat.pri.key;
	memcpy(pk,cert_pk,64);
	memcpy(sk,cert_sk,32);
}

#if WIN32
typedef struct{
	u16 valid;
	u16 rec_id;
	u16 rec_len;
	u8  rec_buf[0x300]; // for private key from pem: {u8 pre1[7]; u8 private_key[32]; u8 pre2[18]; u8 public_key[64];}
}provisioner_record_t;

typedef struct{
	u16 rec_id;
	u16 offset;
	u16 max_size;
}provisioner_record_mag_t;
provisioner_record_mag_t record_mag;

void record_mag_init()
{
	memset(&record_mag,0,sizeof(record_mag));
}

void record_mag_set(u16 rec_id,u16 max_size,u16 offset)
{
	record_mag.rec_id = rec_id;
	record_mag.max_size = max_size;
	record_mag.offset = offset;
}

void record_mag_get(u16 *p_rec_id,u16 *p_max_size,u16 *p_offset)
{
	*p_rec_id = record_mag.rec_id;
	*p_max_size = record_mag.max_size;
	*p_offset = record_mag.offset;
}

void record_mag_get_max_size(u16 *p_max_size)
{
	*p_max_size = record_mag.max_size;
}

provisioner_record_t prov_record[MAX_PROV_RECORD_CNT];

void prov_clear_all_rec()
{
	memset(prov_record,0,sizeof(prov_record));
}

void prov_set_rec_id(u16 *p_rec_data,u8 len)
{
	for(u8 i=0;i<len;i++){
		provisioner_record_t *p_rec = &(prov_record[i]);
		p_rec->valid = 1;
		p_rec->rec_id = p_rec_data[i];
	}
}

int prov_set_buf_len(u16 rec_id,u16 offset,u8 *p_buf,u32 len,u32 total)
{
	// find the rec_id part 
	provisioner_record_t *p_rec;
	for(u8 i=0;i<MAX_PROV_RECORD_CNT;i++){
		p_rec = &(prov_record[i]);
		if(p_rec->valid && p_rec->rec_id == rec_id){
			p_rec->rec_len = total;
			memcpy(p_rec->rec_buf+offset,p_buf,len);
			return 0;
		}
	}
	return -1;
}

u8 der_cert_buf[MAX_PEM_CERT_LEN];
u32 der_buf_len;

int prov_use_rec_id_get_pubkey(u16 rec_id,u8 *p_pubkey)
{
	// find the rec_id part 
	provisioner_record_t *p_rec;
	for(u8 i=0;i<MAX_PROV_RECORD_CNT;i++){
		p_rec = &(prov_record[i]);
		if(p_rec->valid && p_rec->rec_id == rec_id){
			// use the data to get the pubkey part 
			dev_cert_tbs_part_t cert_dat;
			// transfer the private cert to the pubkey and private key
			/*
			der_buf_len = mbedtls_crt_pem2der_define((const u8 *)pem_cert,sizeof(pem_cert),
								der_cert_buf,sizeof(der_cert_buf),PEM_CERT_S,PEM_CERT_E);	
			*/
			if(mbedtls_crt_parse_dev_cert(p_rec->rec_buf,p_rec->rec_len,&cert_dat)!=0){
				return -2;
			}
			memcpy(p_pubkey,cert_dat.pub.key+1,64);
			return 0;
		}
	}
	return -1;
}

	#endif


#if 0 // ecc verify valid and ecdsa is valid or not .
void check_test_pubkey_privatekey_valid()
{
	const u8 ecdsa_hash[]={
		0xa0 ,0x03 ,0x02 ,0x01	,0x02 ,0x02 ,0x02 ,0x10,
		0x00,0x30,0x0a,0x06,	0x08 ,0x2a ,0x86 ,0x48	,0xce ,0x3d ,0x04 ,0x03 	,0x02 ,0x30 ,0x81 ,0xa7,
		0x31,0x0b,0x30,0x09,	0x06 ,0x03 ,0x55 ,0x04	,0x06 ,0x13 ,0x02 ,0x46 	,0x49 ,0x31 ,0x10 ,0x30,
		0x0e,0x06,0x03,0x55,	0x04 ,0x08 ,0x0c ,0x07	,0x55 ,0x75 ,0x73 ,0x69 	,0x6d ,0x61 ,0x61 ,0x31,
		0x0e,0x30,0x0c,0x06,	0x03 ,0x55 ,0x04 ,0x07	,0x0c ,0x05 ,0x45 ,0x73 	,0x70 ,0x6f ,0x6f ,0x31,
		0x18,0x30,0x16,0x06,	0x03 ,0x55 ,0x04 ,0x0a	,0x0c ,0x0f ,0x45 ,0x78 	,0x61 ,0x6d ,0x70 ,0x6c,
		0x65,0x20,0x43,0x6f,	0x6d ,0x70 ,0x61 ,0x6e	,0x79 ,0x31 ,0x19 ,0x30 	,0x17 ,0x06 ,0x03 ,0x55,
		0x04,0x0b,0x0c,0x10,	0x45 ,0x6d ,0x62 ,0x65	,0x64 ,0x64 ,0x65 ,0x64 	,0x20 ,0x44 ,0x65 ,0x76,
		0x69,0x63,0x65,0x73,	0x31 ,0x1d ,0x30 ,0x1b	,0x06 ,0x03 ,0x55 ,0x04 	,0x03 ,0x0c ,0x14 ,0x65,
		0x6d,0x62,0x65,0x64,	0x64 ,0x65 ,0x64 ,0x2e	,0x65 ,0x78 ,0x61 ,0x6d 	,0x70 ,0x6c ,0x65 ,0x2e,
		0x63,0x6f,0x6d,0x31,	0x22 ,0x30 ,0x20 ,0x06	,0x09 ,0x2a ,0x86 ,0x48 	,0x86 ,0xf7 ,0x0d ,0x01,
		0x09,0x01,0x16,0x13,	0x73 ,0x75 ,0x70 ,0x70	,0x6f ,0x72 ,0x74 ,0x40 	,0x65 ,0x78 ,0x61 ,0x6d,
		0x70,0x6c,0x65,0x2e,	0x63 ,0x6f ,0x6d ,0x30	,0x1e ,0x17 ,0x0d ,0x31 	,0x38 ,0x31 ,0x31 ,0x31,
		0x36,0x30,0x37,0x33,	0x34 ,0x34 ,0x36 ,0x5a	,0x17 ,0x0d ,0x31 ,0x39 	,0x31 ,0x31 ,0x31 ,0x36,
		0x30,0x37,0x33,0x34,	0x34 ,0x36 ,0x5a ,0x30	,0x81 ,0x93 ,0x31 ,0x0b 	,0x30 ,0x09 ,0x06 ,0x03,
		0x55,0x04,0x06,0x13,	0x02 ,0x46 ,0x49 ,0x31	,0x10 ,0x30 ,0x0e ,0x06 	,0x03 ,0x55 ,0x04 ,0x08,
		0x0c,0x07,0x55,0x75,	0x73 ,0x69 ,0x6d ,0x61	,0x61 ,0x31 ,0x0e ,0x30 	,0x0c ,0x06 ,0x03 ,0x55,
		0x04,0x07,0x0c,0x05,	0x45 ,0x73 ,0x70 ,0x6f	,0x6f ,0x31 ,0x18 ,0x30 	,0x16 ,0x06 ,0x03 ,0x55,
		0x04,0x0a,0x0c,0x0f,	0x45 ,0x78 ,0x61 ,0x6d	,0x70 ,0x6c ,0x65 ,0x20 	,0x43 ,0x6f ,0x6d ,0x70,
		0x61,0x6e,0x79,0x31,	0x19 ,0x30 ,0x17 ,0x06	,0x03 ,0x55 ,0x04 ,0x0b 	,0x0c ,0x10 ,0x45 ,0x6d,
		0x62,0x65,0x64,0x64,	0x65 ,0x64 ,0x20 ,0x44	,0x65 ,0x76 ,0x69 ,0x63 	,0x65 ,0x73 ,0x31 ,0x2d,
		0x30,0x2b,0x06,0x03,	0x55 ,0x04 ,0x03 ,0x0c	,0x24 ,0x62 ,0x30 ,0x39 	,0x64 ,0x63 ,0x38 ,0x34,
		0x37,0x2d,0x35,0x34,	0x30 ,0x38 ,0x2d ,0x34	,0x30 ,0x63 ,0x63 ,0x2d 	,0x39 ,0x63 ,0x35 ,0x34,
		0x2d,0x30,0x66,0x65,	0x38 ,0x63 ,0x38 ,0x37	,0x34 ,0x32 ,0x39 ,0x65 	,0x37 ,0x30 ,0x59 ,0x30,
		0x13,0x06,0x07,0x2a,	0x86 ,0x48 ,0xce ,0x3d	,0x02 ,0x01 ,0x06 ,0x08 	,0x2a ,0x86 ,0x48 ,0xce,
		0x3d,0x03,0x01,0x07,	0x03 ,0x42 ,0x00 ,0x04	,0x8d ,0x02 ,0x97 ,0xcc 	,0xb3 ,0xe7 ,0xc7 ,0x6b,
		0x15,0x2e,0x0f,0xb0,	0x25 ,0xe4 ,0xe7 ,0x1e	,0x39 ,0x29 ,0xa0 ,0xf0 	,0x9d ,0x2b ,0x8c ,0x45,
		0xf1,0x68,0xb8,0x7e,	0x16 ,0x04 ,0x1d ,0xe4	,0x4b ,0x02 ,0x4c ,0xb8 	,0x06 ,0x34 ,0xfc ,0xd0,
		0x70,0x6c,0x24,0xa8,	0x33 ,0xed ,0xdb ,0x2e	,0xb5 ,0x71 ,0x51 ,0x51 	,0x03 ,0x16 ,0xc9 ,0x89,
		0x3e,0xe4,0xb4,0xbc,	0x85 ,0xf6 ,0xde ,0x59	,0xa3 ,0x81 ,0x87 ,0x30 	,0x81 ,0x84 ,0x30 ,0x09,
		0x06,0x03,0x55,0x1d,	0x13 ,0x04 ,0x02 ,0x30	,0x00 ,0x30 ,0x0b ,0x06 	,0x03 ,0x55 ,0x1d ,0x0f,
		0x04,0x04,0x03,0x02,	0x03 ,0x08 ,0x30 ,0x1d	,0x06 ,0x03 ,0x55 ,0x1d 	,0x0e ,0x04 ,0x16 ,0x04,
		0x14,0x28,0xbc,0x42,	0x6a ,0x68 ,0xdb ,0x63	,0x96 ,0x70 ,0x85 ,0x71 	,0xe4 ,0xcf ,0xc9 ,0x72,
		0x1c,0xe9,0x8b,0x68,	0x15 ,0x30 ,0x1f ,0x06	,0x03 ,0x55 ,0x1d ,0x23 	,0x04 ,0x18 ,0x30 ,0x16,
		0x80,0x14,0xc3,0x7e,	0xea ,0x54 ,0x6a ,0x02	,0x6d ,0x7c ,0xce ,0xf5 	,0xf4 ,0xa0 ,0xd3 ,0xf5,
		0xa8,0xd4,0x98,0x26,	0xa3 ,0x4a ,0x30 ,0x2a	,0x06 ,0x14 ,0x69 ,0x82 	,0xe1 ,0x9d ,0xe4 ,0x91,
		0xea,0xc0,0xc2,0x83,	0x99 ,0x9c ,0xaa ,0x83	,0xfd ,0x8c ,0xc3 ,0xd0 	,0xd3 ,0x67 ,0x04 ,0x12,
		0x04,0x10,0x4e,0x54,	0x34 ,0x6f ,0x70 ,0x46	,0x72 ,0x5a ,0x74 ,0x44 	,0x51 ,0x68 ,0x56 ,0x59,
		0x77,0x67
	};

	u8 A_debug_privatekey[32]={
		0x96,0x17,0xe6,0x00,0x9d,0x5c,0x99,0xfc,0xe7,0x72,0x3f,0x38,0xfc,0xc1,0xdc,0x43,
		0x9b,0x2d,0xf2,0x16,0x91,0x1c,0x8b,0x63,0xeb,0x5c,0xc5,0x26,0xfd,0xf9,0x2a,0x69
	};
	u8 A_debug_pubkey[64]={
		0x8d,0x02,0x97,0xcc,0xb3,0xe7,0xc7,0x6b,0x15,0x2e,0x0f,0xb0,0x25,0xe4,
		0xe7,0x1e,0x39,0x29,0xa0,0xf0,0x9d,0x2b,0x8c,0x45,0xf1,0x68,0xb8,0x7e,0x16,
		0x04,0x1d,0xe4,0x4b,0x02,0x4c,0xb8,0x06,0x34,0xfc,0xd0,0x70,0x6c,0x24,0xa8,
		0x33,0xed,0xdb,0x2e,0xb5,0x71,0x51,0x51,0x03,0x16,0xc9,0x89,0x3e,0xe4,0xb4,
		0xbc,0x85,0xf6,0xde,0x59};
	static u32 A_debug_key_check=0;
	#if 1
	micro_ecc_init();
	u8 A_debug_sha256_hash[32];
	u8 A_debug_sign_dat[64];
	mbedtls_sha256(ecdsa_hash, sizeof(ecdsa_hash), A_debug_sha256_hash, 0);
	micro_ecc_sign(NULL,A_debug_privatekey,A_debug_sha256_hash,A_debug_sign_dat);
	if(micro_ecc_verify(NULL,A_debug_pubkey,A_debug_sha256_hash,A_debug_sign_dat)== 0){
		A_debug_key_check = 0x55;
	}else{
		A_debug_key_check = 0x44;
	}
	#endif
	#if 0 // key is valid
		unsigned char A_pro_dsk[] = { 0x52,0x9a,0xa0,0x67,0x0d,0x72,0xcd,0x64, 0x97,0x50,0x2e,0xd4,0x73,0x50,0x2b,0x03,
						0x7e,0x88,0x03,0xb5,0xc6,0x08,0x29,0xa5, 0xa3,0xca,0xa2,0x19,0x50,0x55,0x30,0xba};
		unsigned char A_pro_dpk[] = { 0xf4,0x65,0xe4,0x3f,0xf2,0x3d,0x3f,0x1b, 0x9d,0xc7,0xdf,0xc0,0x4d,0xa8,0x75,0x81,
						0x84,0xdb,0xc9,0x66,0x20,0x47,0x96,0xec, 0xcf,0x0d,0x6c,0xf5,0xe1,0x65,0x00,0xcc,
						0x02,0x01,0xd0,0x48,0xbc,0xbb,0xd8,0x99, 0xee,0xef,0xc4,0x24,0x16,0x4e,0x33,0xc2,
						0x01,0xc2,0xb0,0x10,0xca,0x6b,0x4d,0x43, 0xa8,0xa1,0x55,0xca,0xd8,0xec,0xb2,0x79};
		u8 k0[32],k1[32];
		micro_ecc_shared_secret_compute(NULL, A_pro_dsk, A_debug_pubkey, k0);
		micro_ecc_shared_secret_compute(NULL, A_debug_privatekey, A_pro_dpk, k1);
		if(!memcmp (k0, k1, 16)){
			A_debug_key_check =1;
		}else{
			A_debug_key_check=0x55;
		}
	#endif

}
#endif
#if 0 // wait for pass the ecdsa-with-sha256 result ,to pass the verify part

int  telink_rand_num_generator(uint8_t* p_buf, uint8_t len)
{
	for(int i=0;i<len;i++){
		p_buf[i]=rand()&0xff;
	}
	return 1;
}

static int telink_swap_endian(const uint8_t *in, uint8_t *out, uint32_t size)
{
    if (out < in + size && in < out + size)
        return -1;

    for(int i = 0; i < size; i++)
        out[i] = in[size-1-i];

    return 0;
}


void sha1_test_der()
{
	/**********
	char input[3]="abc";
	{ 0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,
		  0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D },
	***********/
	static u8 A_debug_pubkey[64]={
		0x8d,0x02,0x97,0xcc,0xb3,0xe7,0xc7,0x6b,0x15,0x2e,0x0f,0xb0,0x25,0xe4,
		0xe7,0x1e,0x39,0x29,0xa0,0xf0,0x9d,0x2b,0x8c,0x45,0xf1,0x68,0xb8,0x7e,0x16,
		0x04,0x1d,0xe4,0x4b,0x02,0x4c,0xb8,0x06,0x34,0xfc,0xd0,0x70,0x6c,0x24,0xa8,
		0x33,0xed,0xdb,0x2e,0xb5,0x71,0x51,0x51,0x03,0x16,0xc9,0x89,0x3e,0xe4,0xb4,
		0xbc,0x85,0xf6,0xde,0x59};

	static u8 A_debug_privatekey[32]={
		0x96,0x17,0xe6,0x00,0x9d,0x5c,0x99,0xfc,0xe7,0x72,0x3f,0x38,0xfc,0xc1,0xdc,0x43,
		0x9b,0x2d,0xf2,0x16,0x91,0x1c,0x8b,0x63,0xeb,0x5c,0xc5,0x26,0xfd,0xf9,0x2a,0x69
	};
	static u8 A_debug_privatekey1[32];
	static u8 A_debug_subject[20]={
		0x28,0xBC,0x42,0x6A,0x68,0xDB,0x63,0x96,0x70,0x85,0x71,0xE4,0xCF,0xC9,0x72,
		0x1C,0xE9,0x8B,0x68,0x15
	};

	static u8 A_debug_authorkey[20]={
		0xC3,0x7E,0xEA,0x54,0x6A,0x02,0x6D,0x7C,0xCE,0xF5,0xF4,0xA0,0xD3,0xF5,0xA8,
		0xD4,0x98,0x26,0xA3,0x4A
	};

	const u8 ecdsa_hash[]={
		0x30,0x82,0x02,0x5a,	0xa0 ,0x03 ,0x02 ,0x01	,0x02 ,0x02 ,0x02 ,0x10,
		0x00,0x30,0x0a,0x06,	0x08 ,0x2a ,0x86 ,0x48	,0xce ,0x3d ,0x04 ,0x03 	,0x02 ,0x30 ,0x81 ,0xa7,
		0x31,0x0b,0x30,0x09,	0x06 ,0x03 ,0x55 ,0x04	,0x06 ,0x13 ,0x02 ,0x46 	,0x49 ,0x31 ,0x10 ,0x30,
		0x0e,0x06,0x03,0x55,	0x04 ,0x08 ,0x0c ,0x07	,0x55 ,0x75 ,0x73 ,0x69 	,0x6d ,0x61 ,0x61 ,0x31,
		0x0e,0x30,0x0c,0x06,	0x03 ,0x55 ,0x04 ,0x07	,0x0c ,0x05 ,0x45 ,0x73 	,0x70 ,0x6f ,0x6f ,0x31,
		0x18,0x30,0x16,0x06,	0x03 ,0x55 ,0x04 ,0x0a	,0x0c ,0x0f ,0x45 ,0x78 	,0x61 ,0x6d ,0x70 ,0x6c,
		0x65,0x20,0x43,0x6f,	0x6d ,0x70 ,0x61 ,0x6e	,0x79 ,0x31 ,0x19 ,0x30 	,0x17 ,0x06 ,0x03 ,0x55,
		0x04,0x0b,0x0c,0x10,	0x45 ,0x6d ,0x62 ,0x65	,0x64 ,0x64 ,0x65 ,0x64 	,0x20 ,0x44 ,0x65 ,0x76,
		0x69,0x63,0x65,0x73,	0x31 ,0x1d ,0x30 ,0x1b	,0x06 ,0x03 ,0x55 ,0x04 	,0x03 ,0x0c ,0x14 ,0x65,
		0x6d,0x62,0x65,0x64,	0x64 ,0x65 ,0x64 ,0x2e	,0x65 ,0x78 ,0x61 ,0x6d 	,0x70 ,0x6c ,0x65 ,0x2e,
		0x63,0x6f,0x6d,0x31,	0x22 ,0x30 ,0x20 ,0x06	,0x09 ,0x2a ,0x86 ,0x48 	,0x86 ,0xf7 ,0x0d ,0x01,
		0x09,0x01,0x16,0x13,	0x73 ,0x75 ,0x70 ,0x70	,0x6f ,0x72 ,0x74 ,0x40 	,0x65 ,0x78 ,0x61 ,0x6d,
		0x70,0x6c,0x65,0x2e,	0x63 ,0x6f ,0x6d ,0x30	,0x1e ,0x17 ,0x0d ,0x31 	,0x38 ,0x31 ,0x31 ,0x31,
		0x36,0x30,0x37,0x33,	0x34 ,0x34 ,0x36 ,0x5a	,0x17 ,0x0d ,0x31 ,0x39 	,0x31 ,0x31 ,0x31 ,0x36,
		0x30,0x37,0x33,0x34,	0x34 ,0x36 ,0x5a ,0x30	,0x81 ,0x93 ,0x31 ,0x0b 	,0x30 ,0x09 ,0x06 ,0x03,
		0x55,0x04,0x06,0x13,	0x02 ,0x46 ,0x49 ,0x31	,0x10 ,0x30 ,0x0e ,0x06 	,0x03 ,0x55 ,0x04 ,0x08,
		0x0c,0x07,0x55,0x75,	0x73 ,0x69 ,0x6d ,0x61	,0x61 ,0x31 ,0x0e ,0x30 	,0x0c ,0x06 ,0x03 ,0x55,
		0x04,0x07,0x0c,0x05,	0x45 ,0x73 ,0x70 ,0x6f	,0x6f ,0x31 ,0x18 ,0x30 	,0x16 ,0x06 ,0x03 ,0x55,
		0x04,0x0a,0x0c,0x0f,	0x45 ,0x78 ,0x61 ,0x6d	,0x70 ,0x6c ,0x65 ,0x20 	,0x43 ,0x6f ,0x6d ,0x70,
		0x61,0x6e,0x79,0x31,	0x19 ,0x30 ,0x17 ,0x06	,0x03 ,0x55 ,0x04 ,0x0b 	,0x0c ,0x10 ,0x45 ,0x6d,
		0x62,0x65,0x64,0x64,	0x65 ,0x64 ,0x20 ,0x44	,0x65 ,0x76 ,0x69 ,0x63 	,0x65 ,0x73 ,0x31 ,0x2d,
		0x30,0x2b,0x06,0x03,	0x55 ,0x04 ,0x03 ,0x0c	,0x24 ,0x62 ,0x30 ,0x39 	,0x64 ,0x63 ,0x38 ,0x34,
		0x37,0x2d,0x35,0x34,	0x30 ,0x38 ,0x2d ,0x34	,0x30 ,0x63 ,0x63 ,0x2d 	,0x39 ,0x63 ,0x35 ,0x34,
		0x2d,0x30,0x66,0x65,	0x38 ,0x63 ,0x38 ,0x37	,0x34 ,0x32 ,0x39 ,0x65 	,0x37 ,0x30 ,0x59 ,0x30,
		0x13,0x06,0x07,0x2a,	0x86 ,0x48 ,0xce ,0x3d	,0x02 ,0x01 ,0x06 ,0x08 	,0x2a ,0x86 ,0x48 ,0xce,
		0x3d,0x03,0x01,0x07,	0x03 ,0x42 ,0x00 ,0x04	,0x8d ,0x02 ,0x97 ,0xcc 	,0xb3 ,0xe7 ,0xc7 ,0x6b,
		0x15,0x2e,0x0f,0xb0,	0x25 ,0xe4 ,0xe7 ,0x1e	,0x39 ,0x29 ,0xa0 ,0xf0 	,0x9d ,0x2b ,0x8c ,0x45,
		0xf1,0x68,0xb8,0x7e,	0x16 ,0x04 ,0x1d ,0xe4	,0x4b ,0x02 ,0x4c ,0xb8 	,0x06 ,0x34 ,0xfc ,0xd0,
		0x70,0x6c,0x24,0xa8,	0x33 ,0xed ,0xdb ,0x2e	,0xb5 ,0x71 ,0x51 ,0x51 	,0x03 ,0x16 ,0xc9 ,0x89,
		0x3e,0xe4,0xb4,0xbc,	0x85 ,0xf6 ,0xde ,0x59	,0xa3 ,0x81 ,0x87 ,0x30 	,0x81 ,0x84 ,0x30 ,0x09,
		0x06,0x03,0x55,0x1d,	0x13 ,0x04 ,0x02 ,0x30	,0x00 ,0x30 ,0x0b ,0x06 	,0x03 ,0x55 ,0x1d ,0x0f,
		0x04,0x04,0x03,0x02,	0x03 ,0x08 ,0x30 ,0x1d	,0x06 ,0x03 ,0x55 ,0x1d 	,0x0e ,0x04 ,0x16 ,0x04,
		0x14,0x28,0xbc,0x42,	0x6a ,0x68 ,0xdb ,0x63	,0x96 ,0x70 ,0x85 ,0x71 	,0xe4 ,0xcf ,0xc9 ,0x72,
		0x1c,0xe9,0x8b,0x68,	0x15 ,0x30 ,0x1f ,0x06	,0x03 ,0x55 ,0x1d ,0x23 	,0x04 ,0x18 ,0x30 ,0x16,
		0x80,0x14,0xc3,0x7e,	0xea ,0x54 ,0x6a ,0x02	,0x6d ,0x7c ,0xce ,0xf5 	,0xf4 ,0xa0 ,0xd3 ,0xf5,
		0xa8,0xd4,0x98,0x26,	0xa3 ,0x4a ,0x30 ,0x2a	,0x06 ,0x14 ,0x69 ,0x82 	,0xe1 ,0x9d ,0xe4 ,0x91,
		0xea,0xc0,0xc2,0x83,	0x99 ,0x9c ,0xaa ,0x83	,0xfd ,0x8c ,0xc3 ,0xd0 	,0xd3 ,0x67 ,0x04 ,0x12,
		0x04,0x10,0x4e,0x54,	0x34 ,0x6f ,0x70 ,0x46	,0x72 ,0x5a ,0x74 ,0x44 	,0x51 ,0x68 ,0x56 ,0x59,
		0x77,0x67
	};
	static u8 A_debug_ecc_sign[64]={
		0xc5,0x59,0x74,0xbb,0x14,0xb7,0xa6,0x82,0x56,0x98,0xab,0x3f,0x35,0xf8,0x7d,0x60,
		0x70,0x68,0x5d,0x26,0x38,0x57,0xf4,0x51,0x43,0x9a,0xcb,0xee,0xaf,0x15,0xfa,0x21,
		0x77,0x67,0xf5,0xbe,0xca,0x9e,0x28,0xdd,0xe9,0x8a,0x9e,0xb7,0x6b,0x86,0x91,0xdc,
		0x93,0x8b,0xd9,0x85,0x55,0xa7,0xc1,0x32,0x44,0xb3,0x13,0xcc,0x2d,0x69,0xa3,0x25
	};
	static u8 A_debug_ecc_sign1[64];
	// use the subject key to do the ecdsa-with_sha256
		static u8 A_debug_sha256_out[32];
		static int A_debug_esdsa_result=0x55;
     	uECC_set_rng(telink_rand_num_generator);
		#if 1
		mbedtls_sha256(ecdsa_hash, sizeof(ecdsa_hash), A_debug_sha256_out, 0);
		// need to transfer the prikey to big endianness
		const struct uECC_Curve_t * p_curve;
		
		p_curve = uECC_secp256r1();
		telink_swap_endian(A_debug_privatekey,A_debug_privatekey1,32);
		A_debug_esdsa_result = uECC_sign(A_debug_privatekey1,A_debug_sha256_out,sizeof(A_debug_sha256_out),A_debug_ecc_sign1,p_curve);
		//uECC_sign
		#endif
}
#endif

#if 0// cert pem decode to der code buf part

void pem_to_der_test_sample()
{


	static u8 A_debug_cert_data[0x2c0],A_debug_cert_data1[128],A_debug_cert_data2[128];
	static u32 A_debug_cer_len,A_debug_cer_len1,A_debug_cer_len2;
	#if 1
	A_debug_cer_len = mbedtls_crt_pem2der_define((const u8 *)pem_cert,sizeof(pem_cert),
		A_debug_cert_data,sizeof(A_debug_cert_data),PEM_CERT_S,PEM_CERT_E);
	#endif
	#if 1
	A_debug_cer_len1 = mbedtls_crt_pem2der_define((const u8 *)para_cert,sizeof(para_cert),
			A_debug_cert_data1,sizeof(A_debug_cert_data1),PEM_EC_S,PEM_EC_E);
	#endif
	#if 1
	A_debug_cer_len2 = mbedtls_crt_pem2der_define((const u8 *)private_cert,sizeof(private_cert),
			A_debug_cert_data2,sizeof(A_debug_cert_data2),PEM_PRIVATE_KEY_S,PEM_PRIVATE_KEY_E);
	#endif

}
#endif


#endif
