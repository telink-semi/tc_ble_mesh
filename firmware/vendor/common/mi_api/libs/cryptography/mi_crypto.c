//#include <string.h>
#include "mi_config.h"

#include "mible_api.h"
#undef  MI_LOG_MODULE_NAME
#define MI_LOG_MODULE_NAME "crypto"
#include "mible_log.h"

#include "mi_mesh_otp.h"
#include "mi_crypto.h"
#include "mi_crypto_backend_msc.h"
#include "mi_crypto_backend_mbedtls.h"
#include "mi_crypto_backend_uECC.h"
#include "third_party/mbedtls/ccm.h"
#include "third_party/mbedtls/sha256.h"
#include "third_party/mbedtls/sha256_hkdf.h"
#include "third_party/mbedtls/md.h"
#include "third_party/pt/pt.h"

#if MI_API_ENABLE
#define CRYPTO_REC_ID_BASE   0x40


static __ALIGN(4) ecc256_sk_t dev_crt_sk;
static __ALIGN(4) ecc256_sk_t dev_sk;
static void keygen(uint8_t k[16])
{
    memset(k, 0, 16);
    mible_gap_address_get(k);
    mible_aes128_encrypt(k, k, 16, k);
}
// for certify part 
#define DEMO_CERT_TYPE0		0//telink
#define DEMO_CERT_TYPE1		1//leishi
#define DEMO_CERT_TYPE2		2
#define DEMO_CERT_TYPE3		3
#define DEMO_CERT_TYPE4		4
#define DEMO_CERT_TYPE5		5
#define DEMO_CERT_TYPE10	10
#define DEMO_CERT_TYPE11	11
#define DEMO_CERT_TYPE12	12
#define DEMO_CERT_TYPE13	13
#define DEMO_CERT_TYPE14	14
#define DEMO_CERT_TYPE15	15
#define DEMO_CERT_TYPE16	16
#define DEMO_CERT_TYPE17	17
#define DEMO_CERT_TYPE18	18
#define DEMO_CERT_TYPE19	19
#define DEMO_CERT_TYPE20	20
#define DEMO_CERT_TYPE21	21
#define DEMO_CERT_TYPE22	22
#define DEMO_CERT_TYPE23	23
#define DEMO_CERT_TYPE24	24
#define DEMO_CERT_TYPE25	25
#define DEMO_CERT_TYPE26	26
#define DEMO_CERT_TYPE27	27
#define DEMO_CERT_TYPE28	28
#define DEMO_CERT_TYPE29	29
#define DEMO_CERT_TYPE30	30
#define DEMO_CERT_TYPE31	31
#define DEMO_CERT_TYPE32	32
#define DEMO_CERT_TYPE33	33
#define DEMO_CERT_TYPE34	34
#define DEMO_CERT_TYPE35	35
#define DEMO_CERT_TYPE36	36
#define DEMO_CERT_TYPE37	37
#define DEMO_CERT_TYPE38	38
#define DEMO_CERT_TYPE39	39
#define DEMO_CERT_TYPE40	40
#define DEMO_CERT_TYPE41	41
#define DEMO_CERT_TYPE42	42
#define DEMO_CERT_TYPE43	43
#define DEMO_CERT_TYPE44	44
#define DEMO_CERT_TYPE45	45
#define DEMO_CERT_TYPE46	46
#define DEMO_CERT_TYPE47	47
#define DEMO_CERT_TYPE48	48
#define DEMO_CERT_TYPE49	49
#define DEMO_CERT_TYPE50	50
#define DEMO_CERT_TYPE51	51
#define DEMO_CERT_TYPE52	52
#define DEMO_CERT_TYPE53	53
#define DEMO_CERT_TYPE54	54
#define DEMO_CERT_TYPE55	55
#define DEMO_CERT_TYPE56	56
#define DEMO_CERT_TYPE57	57
#define DEMO_CERT_TYPE58	58
#define DEMO_CERT_TYPE59	59
#define DEMO_CERT_TYPE60	60
#define DEMO_CERT_TYPE61	61



#define DEMO_CERT_TYPE 	DEMO_CERT_TYPE0

#if (DEMO_CERT_TYPE >= DEMO_CERT_TYPE10)
static const uint8_t manu_cert[] = { // use the customer cert
0x30, 0x82, 0x01, 0x95, 0x30, 0x82, 0x01, 0x3A, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x08, 
0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x30, 0x22, 0x31, 0x13, 
0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0A, 0x4D, 0x69, 0x6A, 0x69, 0x61, 0x20, 0x52, 
0x6F, 0x6F, 0x74, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4E, 
0x30, 0x20, 0x17, 0x0D, 0x31, 0x39, 0x30, 0x35, 0x31, 0x35, 0x30, 0x39, 0x31, 0x31, 0x30, 0x32, 
0x5A, 0x18, 0x0F, 0x32, 0x30, 0x36, 0x39, 0x30, 0x35, 0x30, 0x32, 0x30, 0x39, 0x31, 0x31, 0x30, 
0x32, 0x5A, 0x30, 0x31, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 
0x4E, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x07, 0x4C, 0x45, 0x4C, 0x49, 
0x47, 0x48, 0x54, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x07, 0x4C, 0x45, 
0x4C, 0x49, 0x47, 0x48, 0x54, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 
0x02, 0x01, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 
0x8B, 0x2F, 0x19, 0xAC, 0x84, 0x6C, 0xF1, 0x80, 0xDD, 0x6F, 0xCF, 0xEF, 0xDE, 0x48, 0xC2, 0x3D, 
0x58, 0xD4, 0x2B, 0xA1, 0xBD, 0x57, 0xAC, 0xA8, 0x47, 0x05, 0xF2, 0xB3, 0x22, 0x2B, 0x82, 0x15, 
0x4F, 0xCD, 0x18, 0xCD, 0x19, 0x22, 0xC0, 0xFD, 0xFC, 0xEE, 0x63, 0x14, 0xBA, 0x53, 0x4F, 0xF9, 
0x1D, 0xB9, 0xFA, 0x1B, 0x8B, 0xF6, 0xBC, 0xE3, 0xE8, 0x1D, 0xFA, 0xA7, 0xC0, 0x40, 0x1F, 0x3E, 
0xA3, 0x50, 0x30, 0x4E, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 
0x14, 0x96, 0xB7, 0xA2, 0x7C, 0x39, 0xB1, 0xB9, 0x66, 0x33, 0xA9, 0xF8, 0xD1, 0x09, 0xB2, 0x00, 
0x60, 0xC8, 0xE6, 0xC5, 0x11, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 
0x1C, 0xB0, 0xE6, 0x52, 0x99, 0x69, 0x9A, 0xBA, 0xEC, 0x3A, 0xDC, 0x73, 0x8A, 0xAD, 0x2E, 0x47, 
0x5E, 0xA5, 0x2F, 0x72, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 
0x01, 0xFF, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x03, 0x49, 
0x00, 0x30, 0x46, 0x02, 0x21, 0x00, 0x94, 0xCE, 0x02, 0x85, 0x58, 0x7D, 0x47, 0xE8, 0x09, 0x0D, 
0xAC, 0x6C, 0x66, 0xD2, 0xD1, 0x5F, 0x6C, 0x82, 0x15, 0x7A, 0xB1, 0xC7, 0x53, 0x57, 0x41, 0x98, 
0x4F, 0xCF, 0x3B, 0x9E, 0xC3, 0x6C, 0x02, 0x21, 0x00, 0xAA, 0xC2, 0x98, 0x29, 0xF8, 0xE8, 0x2A, 
0x86, 0x75, 0xD0, 0x8A, 0xDC, 0xE6, 0xAF, 0xDF, 0x24, 0x36, 0xA2, 0x62, 0xDA, 0x15, 0x1A, 0x22, 
0x46, 0xA5, 0x7E, 0x97, 0x30, 0xA2, 0x7C, 0xC2, 0x65, 
};
#else
const uint8_t manu_cert[] = { // use the mi cert
0x30,0x82,0x01,0x8E,0x30,0x82,0x01,0x34,0xA0,0x03,0x02,0x01,0x02,0x02,0x01,0x01,
0x30,0x0A,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x04,0x03,0x02,0x30,0x22,0x31,0x13,
0x30,0x11,0x06,0x03,0x55,0x04,0x0A,0x13,0x0A,0x4D,0x69,0x6A,0x69,0x61,0x20,0x52,
0x6F,0x6F,0x74,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x43,0x4E,
0x30,0x20,0x17,0x0D,0x31,0x37,0x30,0x38,0x30,0x39,0x31,0x32,0x30,0x32,0x34,0x32,
0x5A,0x18,0x0F,0x32,0x30,0x36,0x37,0x30,0x37,0x32,0x38,0x31,0x32,0x30,0x32,0x34,
0x32,0x5A,0x30,0x2B,0x31,0x1C,0x30,0x1A,0x06,0x03,0x55,0x04,0x0A,0x0C,0x13,0x4D,
0x69,0x6A,0x69,0x61,0x20,0x4D,0x61,0x6E,0x75,0x66,0x61,0x63,0x74,0x75,0x72,0x65,
0x20,0x32,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x43,0x4E,0x30,
0x59,0x30,0x13,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,0x06,0x08,0x2A,0x86,
0x48,0xCE,0x3D,0x03,0x01,0x07,0x03,0x42,0x00,0x04,0x50,0xCB,0x0D,0x5B,0x99,0x11,
0x80,0xDD,0xEA,0xA5,0x90,0x6E,0x7D,0x62,0xAF,0x98,0xEA,0xC9,0xCE,0x95,0x61,0xF1,
0x75,0x52,0x1C,0xE9,0x3C,0x7C,0x78,0x6B,0x9A,0x8B,0x86,0x94,0x9A,0x3A,0x76,0x33,
0xC8,0x26,0x01,0xBB,0x9E,0x72,0x3C,0xF0,0x51,0x8C,0xEA,0xCE,0xA4,0xFD,0xD7,0x55,
0x6E,0xD1,0x66,0x83,0x77,0x5A,0x19,0x42,0x55,0x03,0xA3,0x50,0x30,0x4E,0x30,0x1F,
0x06,0x03,0x55,0x1D,0x23,0x04,0x18,0x30,0x16,0x80,0x14,0x96,0xB7,0xA2,0x7C,0x39,
0xB1,0xB9,0x66,0x33,0xA9,0xF8,0xD1,0x09,0xB2,0x00,0x60,0xC8,0xE6,0xC5,0x11,0x30,
0x1D,0x06,0x03,0x55,0x1D,0x0E,0x04,0x16,0x04,0x14,0xFD,0xEF,0xAB,0x24,0x54,0x64,
0xBA,0x88,0xBD,0x04,0x90,0xAF,0xBB,0x5B,0x4B,0x07,0x8F,0x7B,0x49,0xB7,0x30,0x0C,
0x06,0x03,0x55,0x1D,0x13,0x04,0x05,0x30,0x03,0x01,0x01,0xFF,0x30,0x0A,0x06,0x08,
0x2A,0x86,0x48,0xCE,0x3D,0x04,0x03,0x02,0x03,0x48,0x00,0x30,0x45,0x02,0x21,0x00,
0xEB,0x14,0x0C,0x5A,0x0E,0xAB,0x61,0x10,0x7D,0xD6,0x98,0x8A,0xF0,0xEB,0x61,0xFC,
0x5F,0xD0,0x9A,0x0F,0xED,0xC9,0x99,0x24,0x96,0x93,0x49,0xEF,0xE0,0x0E,0xAA,0x0A,
0x02,0x20,0x69,0x09,0x65,0xF8,0x1B,0x9A,0x1D,0x49,0x33,0xB9,0x6F,0xEB,0xFA,0x12,
0x5E,0xE3,0x0D,0xC3,0xB6,0x13,0xA1,0xB0,0x53,0x39,0xFC,0x1A,0xE7,0x87,0x74,0xA4,
0xB3,0x82,
};
#endif

#if MI_IOT_TELINK_MODE
	#if (DEMO_CERT_TYPE == DEMO_CERT_TYPE0)
	#include "./cert/telink_cert0.txt"
	#elif(DEMO_CERT_TYPE == DEMO_CERT_TYPE1)
	#include "./cert/telink_cert1.txt"
	#elif(DEMO_CERT_TYPE == DEMO_CERT_TYPE2)
	#include "./cert/telink_cert2.txt"
	#elif(DEMO_CERT_TYPE == DEMO_CERT_TYPE3)
	#include "./cert/telink_cert3.txt"
	#elif(DEMO_CERT_TYPE == DEMO_CERT_TYPE4)
	#include "./cert/telink_cert4.txt"
	#elif(DEMO_CERT_TYPE == DEMO_CERT_TYPE5)
	#include "./cert/telink_cert5.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE10)
	#include "./cert/telink_cert10.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE11)
	#include "./cert/telink_cert11.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE12)
	#include "./cert/telink_cert12.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE13)
	#include "./cert/telink_cert13.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE14)
	#include "./cert/telink_cert14.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE15)
	#include "./cert/telink_cert15.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE16)
	#include "./cert/telink_cert16.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE17)
	#include "./cert/telink_cert17.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE18)
	#include "./cert/telink_cert18.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE19)
	#include "./cert/telink_cert19.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE20)
	#include "./cert/telink_cert20.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE21)
	#include "./cert/telink_cert21.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE22)
	#include "./cert/telink_cert22.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE23)
	#include "./cert/telink_cert23.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE24)
	#include "./cert/telink_cert24.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE25)
	#include "./cert/telink_cert25.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE26)
	#include "./cert/telink_cert26.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE27)
	#include "./cert/telink_cert27.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE28)
	#include "./cert/telink_cert28.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE29)
	#include "./cert/telink_cert29.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE30)
	#include "./cert/telink_cert30.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE31)
	#include "./cert/telink_cert31.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE32)
	#include "./cert/telink_cert32.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE33)
	#include "./cert/telink_cert33.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE34)
	#include "./cert/telink_cert34.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE35)
	#include "./cert/telink_cert35.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE36)
	#include "./cert/telink_cert36.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE37)
	#include "./cert/telink_cert37.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE38)
	#include "./cert/telink_cert38.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE39)
	#include "./cert/telink_cert39.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE40)
	#include "./cert/telink_cert40.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE41)
	#include "./cert/telink_cert41.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE42)
	#include "./cert/telink_cert42.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE43)
	#include "./cert/telink_cert43.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE44)
	#include "./cert/telink_cert44.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE45)
	#include "./cert/telink_cert45.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE46)
	#include "./cert/telink_cert46.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE47)
	#include "./cert/telink_cert47.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE48)
	#include "./cert/telink_cert48.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE49)
	#include "./cert/telink_cert49.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE50)
	#include "./cert/telink_cert50.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE51)
	#include "./cert/telink_cert51.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE52)
	#include "./cert/telink_cert52.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE53)
	#include "./cert/telink_cert53.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE54)
	#include "./cert/telink_cert54.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE55)
	#include "./cert/telink_cert55.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE56)
	#include "./cert/telink_cert56.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE57)
	#include "./cert/telink_cert57.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE58)
	#include "./cert/telink_cert58.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE59)
	#include "./cert/telink_cert59.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE60)
	#include "./cert/telink_cert60.txt"
	#elif (DEMO_CERT_TYPE == DEMO_CERT_TYPE61)
	#include "./cert/telink_cert61.txt"
	#endif
void set_mi_mac_address(unsigned char *p_mac)
{
    memcpy(p_mac,dev_mac_address,sizeof(dev_mac_address));
}

#else
const unsigned char dev_cert_pri[32] = {0};
const unsigned char demo_certificate[413]={
	0x30,0x82,0x01,0x99,0x30,0x82,0x01,0x3E,0xA0,0x03,0x02,0x01,0x02,0x02,0x04,0x3C,
	0xCB,0xF7,0x0B,0x30,0x0C,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x04,0x03,0x02,0x05,
	0x00,0x30,0x2B,0x31,0x1C,0x30,0x1A,0x06,0x03,0x55,0x04,0x0A,0x13,0x13,0x4D,0x69,
	0x6A,0x69,0x61,0x20,0x4D,0x61,0x6E,0x75,0x66,0x61,0x63,0x74,0x75,0x72,0x65,0x20,
	0x32,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x43,0x4E,0x30,0x20,
	0x17,0x0D,0x31,0x37,0x30,0x38,0x30,0x39,0x31,0x37,0x34,0x38,0x35,0x38,0x5A,0x18,
	0x0F,0x32,0x30,0x36,0x37,0x30,0x37,0x32,0x38,0x31,0x37,0x34,0x38,0x35,0x38,0x5A,
	0x30,0x35,0x31,0x15,0x30,0x13,0x06,0x03,0x55,0x04,0x0A,0x13,0x0C,0x4D,0x69,0x6A,
	0x69,0x61,0x20,0x44,0x65,0x76,0x69,0x63,0x65,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,
	0x04,0x06,0x13,0x02,0x43,0x4E,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04,0x0B,0x13,
	0x06,0x66,0x74,0x73,0x61,0x66,0x65,0x30,0x59,0x30,0x13,0x06,0x07,0x2A,0x86,0x48,
	0xCE,0x3D,0x02,0x01,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07,0x03,0x42,
	0x00,0x04,0xD2,0x07,0x20,0x71,0x54,0xCC,0xB7,0x57,0xE0,0x5F,0x29,0x6F,0xF6,0xE8,
	0x4C,0xCC,0x74,0x09,0xB0,0x52,0xF7,0x20,0x5B,0x29,0x41,0x5F,0xAF,0xB5,0x66,0xFE,
	0xBB,0x5E,0xB5,0x78,0x77,0x79,0x9C,0xBB,0x79,0xBC,0x70,0x4D,0x76,0x33,0x3E,0x1E,
	0x9C,0xA9,0x2D,0x9A,0xB9,0xD6,0xF5,0x86,0x79,0x64,0x3D,0xF4,0x18,0x79,0xB4,0xC7,
	0x66,0x60,0xA3,0x42,0x30,0x40,0x30,0x1D,0x06,0x03,0x55,0x1D,0x0E,0x04,0x16,0x04,
	0x14,0x4A,0x89,0x87,0x3C,0x8D,0xF8,0x0D,0x46,0xE8,0x46,0xB8,0x09,0xBC,0x19,0x0B,
	0x17,0xF8,0x9B,0xC6,0x8F,0x30,0x1F,0x06,0x03,0x55,0x1D,0x23,0x04,0x18,0x30,0x16,
	0x80,0x14,0xFD,0xEF,0xAB,0x24,0x54,0x64,0xBA,0x88,0xBD,0x04,0x90,0xAF,0xBB,0x5B,
	0x4B,0x07,0x8F,0x7B,0x49,0xB7,0x30,0x0C,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x04,
	0x03,0x02,0x05,0x00,0x03,0x47,0x00,0x30,0x44,0x02,0x20,0x39,0x68,0xCF,0x2A,0xCF,
	0x2E,0xD3,0x6C,0x04,0x91,0x54,0xBA,0x1D,0xBE,0x5E,0xF1,0x41,0x80,0x89,0xB3,0x6A,
	0xBD,0xF5,0xFB,0xA7,0xD3,0x45,0x4F,0x26,0xCB,0x78,0xF0,0x02,0x20,0x0E,0xAA,0x73,
	0x80,0x48,0xB8,0xC2,0xEE,0xE5,0x63,0xBD,0xDE,0x01,0xD5,0x1E,0x85,0xE3,0x4B,0xCC,
	0x89,0x81,0xA1,0x38,0x89,0x2C,0x2A,0x12,0x1B,0x23,0x59,0x1B,0x59
};
#endif


int mi_crypto_init(void)
{
    int errno = 0;

#if (HAVE_MSC==0)
    micro_ecc_init(NULL);

#if (HAVE_OTP_PKI)

    uint8_t key[16];
//    uint8_t enc_sk[32+4];
    keygen(key);
/*
    errno = mi_mesh_otp_read(OTP_DEV_CERT_PRI, enc_sk, sizeof(enc_sk));
    if (errno != sizeof(enc_sk))
        return -1;

    errno = mi_crypto_ccm_decrypt(key, key+8, 8, NULL, 0,
                          enc_sk, 32, dev_crt_sk, enc_sk+32, 4);
*/
	#if (MI_CER_MODE == DEMO_CER_MODE)
    memcpy(dev_crt_sk,dev_cert_pri,sizeof(dev_cert_pri)); 
	#elif (MI_CER_MODE == FLASH_CER_MODE)
	// read from the flash 
	mible_nvm_read(dev_crt_sk,sizeof(dev_crt_sk),DEV_SK_FLASH_ADR);
	#endif
	#if SOFT_CRYPTO_ENABLE
	return ECC_SUC_RET;
	#else
    MI_ERR_CHECK(errno);
    return errno;
	#endif
#endif
#endif
    return 0;
}

int mi_crypto_ecc_keypair_gen(ecc_curve_t curve, ecc256_pk_t pk)
{
    if (pk == 0)
        return -1;

#if (HAVE_MSC)
    return msc_ecc_keypair_gen(&curve, pk);
#else
	#if SOFT_CRYPTO_ENABLE
	tn_p256_keypair (dev_sk, pk, pk+32);
    return ECC_SUC_RET;
	#else
    int ret = micro_ecc_keypair_gen(&curve, dev_sk, pk);
    MI_ERR_CHECK(ret);
    return (ret == MI_SUCCESS ? PT_ENDED : ret);
	#endif
#endif
}

int mi_crypto_ecc_pubkey_compute(ecc_curve_t curve, const ecc256_sk_t sk, ecc256_pk_t pk)
{
#if (HAVE_MSC)
    return -1;
#else
    if (sk == 0 || pk == 0)
        return -1;
	#if SOFT_CRYPTO_ENABLE
	tn_p256_keypair_sk((unsigned char *)sk,pk,pk+32);
	return ECC_SUC_RET;
	#else
    int ret = micro_ecc_public_key_compute(&curve, sk, pk);
    MI_ERR_CHECK(ret);
    return (ret == MI_SUCCESS ? PT_ENDED : ret);
	#endif
#endif
}

int mi_crypto_ecc_shared_secret_compute(ecc_curve_t curve, const ecc256_pk_t pk, ecc256_ss_t ss)
{
    if (pk == 0 || ss == 0)
        return -1;

#if (HAVE_MSC)
    return msc_ecdh(&curve, pk, ss);
#else
	#if SOFT_CRYPTO_ENABLE
	tn_p256_dhkey (ss, dev_sk, (unsigned char *)pk, (unsigned char *)(pk+32));
	return ECC_SUC_RET;
	#else
    int ret = micro_ecc_shared_secret_compute(&curve, dev_sk, pk, ss);
    MI_ERR_CHECK(ret);
    return (ret == MI_SUCCESS ? PT_ENDED : ret);
	#endif
#endif
}

int mi_crypto_ecc_sign(ecc_curve_t curve, const uint8_t *p_hash, uint8_t *p_sig)
{
    if (p_hash == 0 || p_sig == 0)
        return -1;

#if (HAVE_MSC)
    return msc_ecdsa_sign(&curve, p_hash, p_sig);
#else
	#if SOFT_CRYPTO_ENABLE
	const struct uECC_Curve_t * curve_t = uECC_secp256r1();
	uECC_sign((const uint8_t *)dev_crt_sk, (const uint8_t *)p_hash,
	      32, p_sig, curve_t);
	return ECC_SUC_RET;
	#else
    int ret = micro_ecc_sign(&curve, (const uint8_t *)dev_crt_sk, (const uint8_t *)p_hash, p_sig);
    MI_ERR_CHECK(ret);
    return (ret == MI_SUCCESS ? PT_ENDED : PT_EXITED);
	#endif
#endif
}

int mi_crypto_ecc_verify(ecc_curve_t curve, const ecc256_pk_t pk, const uint8_t *p_hash, const uint8_t *p_sig)
{
    if (pk == 0 || p_hash == 0 || p_sig == 0)
        return -1;

#if (HAVE_MSC)
    return msc_ecdsa_verify(&curve, pk, p_hash, p_sig);
#else
	#if SOFT_CRYPTO_ENABLE
	const struct uECC_Curve_t * curve_t = uECC_secp256r1();
	int ret = uECC_verify((const uint8_t *)pk,(const uint8_t *)p_hash,
				32,(const uint8_t *)p_sig,curve_t);
	if(ret) return ECC_SUC_RET;
	else return PT_EXITED;
	#else
    int ret = micro_ecc_verify(&curve, (const uint8_t *)pk, (const uint8_t *)p_hash, (const uint8_t *)p_sig);
    MI_ERR_CHECK(ret);
    return (ret == MI_SUCCESS ? PT_ENDED : PT_EXITED);
	#endif
#endif
}
void test_ecdsa_sig_verify1()
{
#if 0 // just test for the caculate funtion time
	static u32 A_debug_sig_key_make0=0;
	static u32 A_debug_sig_key_make1=0;
	static u32 A_debug_sig_key_make2=0;
	
	static u32 A_debug_sig_sign0=0;
	static u32 A_debug_sig_sign1=0;
	static u32 A_debug_sig_sign2=0;
	
	static u32 A_debug_sig_ver0=0;
	static u32 A_debug_sig_ver1=0;
	static u32 A_debug_sig_ver2=0;

	micro_ecc_init(NULL);
	unsigned char dev_dsk[] = { 0x52,0x9a,0xa0,0x67,0x0d,0x72,0xcd,0x64, 0x97,0x50,0x2e,0xd4,0x73,0x50,0x2b,0x03,
						0x7e,0x88,0x03,0xb5,0xc6,0x08,0x29,0xa5, 0xa3,0xca,0xa2,0x19,0x50,0x55,0x30,0xba};
	unsigned char dev_dpk[] = { 0xf4,0x65,0xe4,0x3f,0xf2,0x3d,0x3f,0x1b, 0x9d,0xc7,0xdf,0xc0,0x4d,0xa8,0x75,0x81,
						0x84,0xdb,0xc9,0x66,0x20,0x47,0x96,0xec, 0xcf,0x0d,0x6c,0xf5,0xe1,0x65,0x00,0xcc,
						0x02,0x01,0xd0,0x48,0xbc,0xbb,0xd8,0x99, 0xee,0xef,0xc4,0x24,0x16,0x4e,0x33,0xc2,
						0x01,0xc2,0xb0,0x10,0xca,0x6b,0x4d,0x43, 0xa8,0xa1,0x55,0xca,0xd8,0xec,0xb2,0x79};
	unsigned char dev_dpk_test[64];


	unsigned char hash_dat[32]={0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7, 
								0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7};
	unsigned char sign_dat[64];
	A_debug_sig_key_make0=clock_time();
	mi_crypto_ecc_keypair_gen(P256R1,dev_dpk_test);
	A_debug_sig_key_make1=clock_time();
	A_debug_sig_key_make2 = (A_debug_sig_key_make1 - A_debug_sig_key_make0)/32;

	A_debug_sig_sign0 = clock_time();
	mi_crypto_ecc_sign(P256R1,hash_dat,sign_dat);
	A_debug_sig_sign1 = clock_time();
	A_debug_sig_sign2 = (A_debug_sig_sign1 - A_debug_sig_sign0)/32;

	A_debug_sig_ver0 = clock_time();
	mi_crypto_ecc_verify(P256R1,dev_dpk,hash_dat,sign_dat);
	A_debug_sig_ver1 = clock_time();
	A_debug_sig_ver2 = (A_debug_sig_ver1 -A_debug_sig_ver0 )/32;
#else
	// test for ecc part 
	/*
	micro_ecc_init(NULL);
	static u32 A_debug_sk_calc = 0;
	int ret;
	unsigned char x0[64],y0[64],k0[32],k1[32];

	unsigned char s0[32] = {
		0x20,0xb0,0x03,0xd2,0xf2,0x97,0xbe,0x2c,0x5e,0x2c,0x83,0xa7,0xe9,0xf9,0xa5,0xb9,
		0xef,0xf4,0x91,0x11,0xac,0xf4,0xfd,0xdb,0xcc,0x03,0x01,0x48,0x0e,0x35,0x9d,0xe6};

	unsigned char s1[32] = {
		0x55,0x18,0x8b,0x3d,0x32,0xf6,0xbb,0x9a,0x90,0x0a,0xfc,0xfb,0xee,0xd4,0xe7,0x2a,
		0x59,0xcb,0x9a,0xc2,0xf1,0x9d,0x7c,0xfb,0x6b,0x4f,0xdd,0x49,0xf4,0x7f,0xc5,0xfd};
	micro_ecc_keypair_gen(NULL, s0, x0);
	micro_ecc_keypair_gen(NULL, s1, y0);
	micro_ecc_shared_secret_compute(NULL, s0, y0, k0);
	micro_ecc_shared_secret_compute(NULL, s1, x0, k1);
	ret = memcmp (k0, k1, 16);
	if(ret == 0){
		A_debug_sk_calc++;
	}else{
		A_debug_sk_calc=0x55;
	}		
	*/

	// test for the part of the 
	/*
	micro_ecc_init(NULL);
	u8 ecdsa_sk[32];
	u8 ecdsa_pk[64];
	micro_ecc_keypair_gen(NULL, ecdsa_sk, ecdsa_pk);
	static u32 A_debug_sk_calc = 0;
	unsigned char hash_dat[32]={0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7, 
								0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7};
	unsigned char sign_dat[64];
	micro_ecc_sign(NULL, ecdsa_sk, hash_dat, sign_dat);
	if(micro_ecc_verify(NULL, ecdsa_pk, hash_dat, sign_dat)==0){
		A_debug_sk_calc =2;
	}else{
		A_debug_sk_calc =0x55;
	}
	*/
#endif
}


int mi_crypto_get_crt_len(uint16_t *p_dev_len, uint16_t *p_manu_len, uint16_t *p_root_len)
{
#if (HAVE_MSC)
    return msc_get_cert_len(p_dev_len, p_manu_len, p_root_len);
#elif (HAVE_OTP_PKI)
    #if (MI_CER_MODE == DEMO_CER_MODE)
    p_dev_len  ? *p_dev_len  = sizeof(demo_certificate):0;//mi_mesh_otp_read(OTP_DEV_CERT, NULL, 0) : 0;
	p_manu_len ? *p_manu_len = sizeof(manu_cert):0;
	p_root_len ? *p_root_len = mi_root_cert_len():0;
	#elif (MI_CER_MODE == FLASH_CER_MODE)
	p_dev_len  ? *p_dev_len =  mi_mesh_otp_read(OTP_DEV_CERT, NULL, 0) : 0;
	p_manu_len ? *p_manu_len = mi_mesh_otp_read(OTP_MANU_CERT, NULL, 0) : 0;
    p_root_len ? *p_root_len = mi_mesh_otp_read(OTP_ROOT_CERT, NULL, 0) : 0;
    #endif
    
    return PT_ENDED;
#else
    return PT_ENDED;
#endif
}

u16 get_manu_cert_len()
{
	return sizeof(manu_cert);
}

u8 * get_manu_cert_pointer()
{
	return manu_cert;
}

int mi_crypto_get_crt_der(mi_cert_t type, uint8_t *p_der, uint16_t der_len)
{
    if (p_der == NULL)
        return -1;

#if (HAVE_MSC)
    msc_cmd_t cmd = MSC_NOP;
    switch(type) {
    case MI_DEV_CERT:
        cmd = MSC_DEV_CERT;
        break;
    case MI_MANU_CERT:
        cmd = MSC_MANU_CERT;
        break;
    case MI_ROOT_CERT:
        cmd = MSC_ROOT_CERT;
        break;
    }
    return msc_get_cert_der(cmd, p_der, der_len);
#elif (HAVE_OTP_PKI)
    uint16_t item;
    switch(type) {
    case MI_DEV_CERT:
        item = OTP_DEV_CERT;
		// certiry memcpy
		#if (MI_CER_MODE == DEMO_CER_MODE)
		memcpy(p_der,demo_certificate,der_len);
		#elif(MI_CER_MODE == FLASH_CER_MODE)
		#endif
        break;
    case MI_MANU_CERT:
		#if (MI_CER_MODE == DEMO_CER_MODE)
		memcpy(p_der,manu_cert,der_len);
		#endif
        item = OTP_MANU_CERT;
        break;
    case MI_ROOT_CERT:
        item = OTP_ROOT_CERT;
        break;
    }
    mi_mesh_otp_read(item, p_der, der_len);
    return PT_ENDED;
#else

    return PT_ENDED;
#endif
}

int mi_crypto_crt_parse_der(const unsigned char *crt, size_t crt_sz,
        const msc_crt_time *now, msc_crt_t *msc_crt)
{
    return mbedtls_crt_parse_der(crt, crt_sz, now, msc_crt);
}

int mi_crypto_hash_init(void * p_ctx);

int mi_crypto_hash_update(void *p_ctx, uint8_t *p_data, uint16_t data_len);

int mi_crypto_hash_finish(void *p_ctx, uint8_t *p_digest, uint8_t *p_digest_len);

int mi_crypto_sha256(uint8_t *p_in, uint32_t in_len, uint8_t *p_out)
{
    mbedtls_sha256(p_in, in_len, p_out, 0);
    return 0;
}

int mi_crypto_hkdf_sha256(const uint8_t *key, uint8_t key_len, const uint8_t *salt, uint8_t salt_len,
                        const uint8_t *info, uint16_t info_len, uint8_t *out, uint8_t out_len)
{
    return mbedtls_sha256_hkdf(key, key_len, salt, salt_len, info, info_len, out, out_len);
}

int mi_crypto_hmac_init(void *p_ctx, uint8_t *k, uint8_t key_len);

int mi_crypto_hmac_update(void *p_ctx, uint8_t *p_data, uint16_t data_len);

int mi_crypto_hmac_finish(void *p_ctx, uint8_t *p_digest, uint8_t *p_digest_len);

int mi_crypto_hmac_sha256(const uint8_t *k, uint32_t key_len, 
    const uint8_t *p_in, uint32_t in_len, uint8_t *p_out)
{
    const mbedtls_md_info_t * sha256 = mbedtls_md_info_from_string("SHA256");
    return mbedtls_md_hmac(sha256, k, key_len, p_in, in_len, p_out);
}

int mi_crypto_ccm_encrypt(const uint8_t *key,
                         const uint8_t *iv, size_t iv_len,
                         const uint8_t *add, size_t add_len,
                         const uint8_t *in, size_t in_len,
                         uint8_t *out,
                         uint8_t *tag, size_t tag_len )
{
    int ret = aes_ccm_encrypt_and_tag(key, iv, iv_len, add, add_len,
                                    in, in_len, out, tag, tag_len );
    return ret;
}

int mi_crypto_ccm_decrypt( const uint8_t *key,
                        const uint8_t *iv, size_t iv_len,
                        const uint8_t *add, size_t add_len,
                        const uint8_t *in, size_t in_len,
                        uint8_t *out,
                        const uint8_t *tag, size_t tag_len )
{
    int ret = aes_ccm_auth_decrypt(key, iv, iv_len, add, add_len,
                                    in, in_len, out, tag, tag_len );
    return ret;
}

int mi_crypto_record_write(uint8_t record_id, const uint8_t *p_data, uint8_t len)
{
    if (p_data == NULL)
        return -1;
#if (HAVE_MSC)
    return msc_record_write(record_id, p_data, len);
#else
    uint8_t key[16] = {0};
    uint8_t tmp[len+4];
    int ret;
    keygen(key);
    ret = mi_crypto_ccm_encrypt(key, key + 8, 8, NULL, 0, p_data, len, tmp, tmp + len, 4);
    MI_ERR_CHECK(ret);
    ret = mible_record_create(CRYPTO_REC_ID_BASE + record_id, len + 4);
    MI_ERR_CHECK(ret);
    ret = mible_record_write(CRYPTO_REC_ID_BASE + record_id, tmp, len + 4);
    MI_ERR_CHECK(ret);
    return (ret == MI_SUCCESS ? PT_ENDED : PT_EXITED);
#endif

}

int mi_crypto_record_read(uint8_t record_id, uint8_t *p_data, uint8_t len)
{
    if (p_data == NULL)
        return -1;

#if (HAVE_MSC)
    return msc_record_read(record_id, p_data, len);
#else
    uint8_t key[16] = {0};
    uint8_t tmp[len+4];
    int ret = mible_record_read(CRYPTO_REC_ID_BASE + record_id, tmp, len + 4);
    MI_ERR_CHECK(ret);
    keygen(key);
    ret = mi_crypto_ccm_decrypt(key, key+8, 8, NULL, 0, tmp, len, p_data, tmp + len, 4);
    MI_ERR_CHECK(ret);
    return (ret == MI_SUCCESS ? PT_ENDED : PT_EXITED);
#endif

}

int mi_crypto_record_delete(uint8_t record_id)
{
#if (HAVE_MSC)
    return msc_record_delete(record_id);
#else
    int ret = mible_record_delete(CRYPTO_REC_ID_BASE + record_id);
    MI_ERR_CHECK(ret);
    return (ret == MI_SUCCESS ? PT_ENDED : PT_EXITED);
#endif
}

#endif
